<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.79.0" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="pwaer" />
  <meta property="og:url" content="https://pwaer.ink/blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/" />
  <link rel="canonical" href="https://pwaer.ink/blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/" /><link rel="alternate" type="application/atom+xml" href="https://pwaer.ink/index.xml" title="Pwaer&#39;s Blog">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/pwaer.ink\/"
      },
      "articleSection" : "blog",
      "name" : "算法与数据结构总结",
      "headline" : "算法与数据结构总结",
      "description" : "CLRS快撸完一半了，所以趁开学前做下小总结，CLRS研究问题的方式和平时的感觉有那么些不太一样，但是接触久了就会慢慢习惯，主要注重算法的运行时间和算法可行性。初阶学习目标是掌握几种重要的排序算法和课堂中没有学到的数据结构。\n首先还要推荐一下usfca的这个算法可视化的网站：https:\/\/www.cs.usfca.edu\/~galles\/visualization\/RedBlack.html\n排序算法 排序算法在系统学习之前，只会冒泡排序，非常简单但是时间复杂度为O(n^2)的算法，是一种没有怎么优化过的想法。\n插入排序 插入排序(insert sort)是学习CLRS最先接触的算法，可以理解为将序列中的元素插入到一个已经排序好的队列中去。提供一个序列的起始位置(be)和长度(len)，循环从起始位置的下一个元素开始迭代，作为需要插入的数值(key)，将所有大于关键字元素后移一位，最后在放入对应的位置。期望运行时间(n^2)。\nfor (int i = be \u002b 1; i \u0026lt; len; i\u002b\u002b) { int key = a[i]; int j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; a[j] \u0026gt; key) { a[j\u002b1] = a[j]; j--; } a[j\u002b1] = key; } 归并排序 归并排序(merge sort)是接触分治法接触到的算法，这种方法是将需要解决的问题细分为细小的问题，然后递归求解这些子问题，直接求解，最后将这些子问题的解合并成原问题的解。应用到排序算法中的话就是将待排序的元素分成n\/2两个子序列，然后递归解决子序列的顺序问题，最后合并两个已排序的子序列，形成排序好的队列。期望运行时间(nlgn)。\n首先是归并过程的辅助函数:\nvoid SortAlgorithm::mergeArray(int p, int q, int r) { int n1 = q - p \u002b 1; int n2 = r - q; int L[n1], R[n2]; int i1, i2; for (int i = 0; i \u0026lt; n1; i\u002b\u002b) L[i] = a[p\u002bi]; for (int i = 0; i \u0026lt; n2; i\u002b\u002b) R[i] = a[q\u002bi\u002b1]; i1 = 0; i2 = 0; for (int k = p; k \u0026lt;= r; k\u002b\u002b) { if ((L[i1] \u0026lt;= R[i2] \u0026amp;\u0026amp; i1 \u0026lt; n1 )|| i2 == n2) { a[k] = L[i1]; i1\u002b\u002b; } else { a[k] = R[i2]; i2\u002b\u002b; } } } 前面两个for循环是赋值递归过程已经排好的两个子数组left和right，然后根据i1和i2所指向的数组元素大小放入到原来的数组中去，完成两个子数组的归并。",
      "inLanguage" : "en-US",
      "author" : "pwaer",
      "creator" : "pwaer",
      "publisher": "pwaer",
      "accountablePerson" : "pwaer",
      "copyrightHolder" : "pwaer",
      "copyrightYear" : "2018",
      "datePublished": "2018-09-09 18:41:48 \u002b0000 UTC",
      "dateModified" : "2018-09-09 18:41:48 \u002b0000 UTC",
      "url" : "https:\/\/pwaer.ink\/blog\/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93\/",
      "keywords" : [ "algorithm", ]
  }
</script>
<title>算法与数据结构总结</title>
  <meta property="og:title" content="算法与数据结构总结" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="CLRS快撸完一半了，所以趁开学前做下小总结，CLRS研究问题的方式和平时的感觉有那么些不太一样，但是接触久了就会慢慢习惯，主要注重算法的运行时间和算法可行性。初阶学习目标是掌握几种重要的排序算法和课堂中没有学到的数据结构。
首先还要推荐一下usfca的这个算法可视化的网站：https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
排序算法 排序算法在系统学习之前，只会冒泡排序，非常简单但是时间复杂度为O(n^2)的算法，是一种没有怎么优化过的想法。
插入排序 插入排序(insert sort)是学习CLRS最先接触的算法，可以理解为将序列中的元素插入到一个已经排序好的队列中去。提供一个序列的起始位置(be)和长度(len)，循环从起始位置的下一个元素开始迭代，作为需要插入的数值(key)，将所有大于关键字元素后移一位，最后在放入对应的位置。期望运行时间(n^2)。
for (int i = be &#43; 1; i &amp;lt; len; i&#43;&#43;) { int key = a[i]; int j = i - 1; while (j &amp;gt;= 0 &amp;amp;&amp;amp; a[j] &amp;gt; key) { a[j&#43;1] = a[j]; j--; } a[j&#43;1] = key; } 归并排序 归并排序(merge sort)是接触分治法接触到的算法，这种方法是将需要解决的问题细分为细小的问题，然后递归求解这些子问题，直接求解，最后将这些子问题的解合并成原问题的解。应用到排序算法中的话就是将待排序的元素分成n/2两个子序列，然后递归解决子序列的顺序问题，最后合并两个已排序的子序列，形成排序好的队列。期望运行时间(nlgn)。
首先是归并过程的辅助函数:
void SortAlgorithm::mergeArray(int p, int q, int r) { int n1 = q - p &#43; 1; int n2 = r - q; int L[n1], R[n2]; int i1, i2; for (int i = 0; i &amp;lt; n1; i&#43;&#43;) L[i] = a[p&#43;i]; for (int i = 0; i &amp;lt; n2; i&#43;&#43;) R[i] = a[q&#43;i&#43;1]; i1 = 0; i2 = 0; for (int k = p; k &amp;lt;= r; k&#43;&#43;) { if ((L[i1] &amp;lt;= R[i2] &amp;amp;&amp;amp; i1 &amp;lt; n1 )|| i2 == n2) { a[k] = L[i1]; i1&#43;&#43;; } else { a[k] = R[i2]; i2&#43;&#43;; } } } 前面两个for循环是赋值递归过程已经排好的两个子数组left和right，然后根据i1和i2所指向的数组元素大小放入到原来的数组中去，完成两个子数组的归并。" />
  <meta name="description" content="CLRS快撸完一半了，所以趁开学前做下小总结，CLRS研究问题的方式和平时的感觉有那么些不太一样，但是接触久了就会慢慢习惯，主要注重算法的运行时间和算法可行性。初阶学习目标是掌握几种重要的排序算法和课堂中没有学到的数据结构。
首先还要推荐一下usfca的这个算法可视化的网站：https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
排序算法 排序算法在系统学习之前，只会冒泡排序，非常简单但是时间复杂度为O(n^2)的算法，是一种没有怎么优化过的想法。
插入排序 插入排序(insert sort)是学习CLRS最先接触的算法，可以理解为将序列中的元素插入到一个已经排序好的队列中去。提供一个序列的起始位置(be)和长度(len)，循环从起始位置的下一个元素开始迭代，作为需要插入的数值(key)，将所有大于关键字元素后移一位，最后在放入对应的位置。期望运行时间(n^2)。
for (int i = be &#43; 1; i &amp;lt; len; i&#43;&#43;) { int key = a[i]; int j = i - 1; while (j &amp;gt;= 0 &amp;amp;&amp;amp; a[j] &amp;gt; key) { a[j&#43;1] = a[j]; j--; } a[j&#43;1] = key; } 归并排序 归并排序(merge sort)是接触分治法接触到的算法，这种方法是将需要解决的问题细分为细小的问题，然后递归求解这些子问题，直接求解，最后将这些子问题的解合并成原问题的解。应用到排序算法中的话就是将待排序的元素分成n/2两个子序列，然后递归解决子序列的顺序问题，最后合并两个已排序的子序列，形成排序好的队列。期望运行时间(nlgn)。
首先是归并过程的辅助函数:
void SortAlgorithm::mergeArray(int p, int q, int r) { int n1 = q - p &#43; 1; int n2 = r - q; int L[n1], R[n2]; int i1, i2; for (int i = 0; i &amp;lt; n1; i&#43;&#43;) L[i] = a[p&#43;i]; for (int i = 0; i &amp;lt; n2; i&#43;&#43;) R[i] = a[q&#43;i&#43;1]; i1 = 0; i2 = 0; for (int k = p; k &amp;lt;= r; k&#43;&#43;) { if ((L[i1] &amp;lt;= R[i2] &amp;amp;&amp;amp; i1 &amp;lt; n1 )|| i2 == n2) { a[k] = L[i1]; i1&#43;&#43;; } else { a[k] = R[i2]; i2&#43;&#43;; } } } 前面两个for循环是赋值递归过程已经排好的两个子数组left和right，然后根据i1和i2所指向的数组元素大小放入到原来的数组中去，完成两个子数组的归并。" />
  <meta property="og:locale" content="en-us" />

  
    <style>body{font-family:bree serif,sans-serif;-webkit-font-smoothing:antialiased;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{font-size:18px;max-width:100%}.markdown-body a{text-decoration:underline;text-decoration-color:#000}.markdown-body pre{padding:16px;overflow:auto;border-radius:10px}.markdown-body code{padding:.2em .4em;font-size:85%;background-color:#f6f8fa;border-radius:6px}.markdown-body pre>code{padding:0;font-size:100%;background-color:inherit;border:0}.Chinese .markdown-body{line-height:200%}.site-date-catalog{font-size:2rem}.header-title{font-size:2rem;font-weight:700;margin-top:32px;font-family:bungee shade,sans-serif}.header-title a{text-decoration:none}.header-subtitle{color:#666}.header-items{margin:10px 0}.header-item{margin:0 5px}.header-line{width:100%;border-width:2px;border-color:#482936;border-style:solid none none none}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-line{font-size:1.2rem;margin:12px 0}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px}.site-footer{margin-top:50px}.site-footer-item{margin-right:12px}.post-content img{max-width:100%;display:block;margin-right:auto;margin-top:12px}.post-header{margin-bottom:50px}.post-title{font-size:2rem;font-weight:600}.post-tags{display:inline;font-weight:600;padding:2px 5px;margin-right:6px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800;font-style:italic}.post-author{float:right;font-weight:600}.page-content{min-height:60%}.post-content{margin-bottom:50px}.post-content p{hyphens:auto;line-height:1.8;text-justify:ideographic;margin-bottom:1em}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}@media screen and (max-width:600px){.header-title,.header-subtitle,.header-items{text-align:center}.posts-line{font-size:16px}.markdown-body{font-size:16px}.post-title{font-size:2rem}.post-content p{letter-spacing:.05em}}@media screen and (max-width:48em){.posts-category{display:none}}</style>
  
  
    <style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style>
  

  

  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Pwaer&#39;s Blog">
  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel="stylesheet">
  
  

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-LGMCE8D1GT"></script><script>window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag("js", new Date()); gtag("config", "G-LGMCE8D1GT");</script>
</head>


<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="header-title">
    <a href="/"
      >Learning machine</a
    >
  </div>
  <div class="header-subtitle"></div>
</header>
<div class="row end-md center-xs header-items">
  
  <div class="header-item">
    <a href="/about">About Me</a>
  </div>
  
  <div class="header-item">
    <a href="/path">World</a>
  </div>
  
  <div class="header-item">
    <a href="https://github.com/fatwaer">Github</a>
  </div>
  
</div>
<div class="row end-xs">
   
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">算法与数据结构总结</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2018-09-09 18:41:48 UTC">
                09 Sep 2018
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="https//github.com/fatwaer">@pwaer</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <p>CLRS快撸完一半了，所以趁开学前做下小总结，CLRS研究问题的方式和平时的感觉有那么些不太一样，但是接触久了就会慢慢习惯，主要注重算法的运行时间和算法可行性。初阶学习目标是掌握几种重要的排序算法和课堂中没有学到的数据结构。</p>
<p>首先还要推荐一下usfca的这个算法可视化的网站：https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</p>
<h1 id="排序算法">排序算法</h1>
<p>排序算法在系统学习之前，只会冒泡排序，非常简单但是时间复杂度为O(n^2)的算法，是一种没有怎么优化过的想法。</p>
<h2 id="插入排序">插入排序</h2>
<p>插入排序(insert sort)是学习CLRS最先接触的算法，可以理解为将序列中的元素插入到一个已经排序好的队列中去。提供一个序列的起始位置(be)和长度(len)，循环从起始位置的下一个元素开始迭代，作为需要插入的数值(key)，将所有大于关键字元素后移一位，最后在放入对应的位置。期望运行时间(n^2)。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-fallback" data-lang="fallback">    for (int i = be + 1; i &lt; len; i++) {
        int key = a[i];
        int j = i - 1;
        while (j &gt;= 0 &amp;&amp; a[j] &gt; key) {
            a[j+1] = a[j];
            j--;
        }
        a[j+1] = key;
    }
</code></pre></div><h2 id="归并排序">归并排序</h2>
<p>归并排序(merge sort)是接触分治法接触到的算法，这种方法是将需要解决的问题细分为细小的问题，然后递归求解这些子问题，直接求解，最后将这些子问题的解合并成原问题的解。应用到排序算法中的话就是将待排序的元素分成n/2两个子序列，然后递归解决子序列的顺序问题，最后合并两个已排序的子序列，形成排序好的队列。期望运行时间(nlgn)。</p>
<p>首先是归并过程的辅助函数:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
SortAlgorithm::mergeArray(<span style="">int</span> p, <span style="">int</span> q, <span style="">int</span> r)
{
    <span style="">int</span> n1 = q - p + 1;
    <span style="">int</span> n2 = r - q;
    <span style="">int</span> L[n1], R[n2];
    <span style="">int</span> i1, i2;

    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt; n1; i++)
        L[i] = a[p+i];
    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt; n2; i++)
        R[i] = a[q+i+1];

    i1 = 0;
    i2 = 0;
    <span style="font-weight:bold">for</span> (<span style="">int</span> k = p; k &lt;= r; k++) {
        <span style="font-weight:bold">if</span> ((L[i1] &lt;= R[i2] &amp;&amp; i1 &lt; n1 )|| i2 == n2) {
            a[k] = L[i1];
            i1++;
        } <span style="font-weight:bold">else</span> {
            a[k] = R[i2];
            i2++;
        }
    }
}
</code></pre></div><p>前面两个for循环是赋值递归过程已经排好的两个子数组left和right，然后根据i1和i2所指向的数组元素大小放入到原来的数组中去，完成两个子数组的归并。</p>
<p>然后是一个将问题分解的递归过程:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
SortAlgorithm::mergeSort(<span style="">int</span> p, <span style="">int</span> r)
{
    <span style="">int</span> q;

    <span style="font-weight:bold">if</span> (p &lt; r) {
        q = (r + p) / 2;

        mergeSort(p, q);
        mergeSort(q+1, r);

        mergeArray(p, q, r);
    }
}
</code></pre></div><h2 id="主定理">主定理</h2>
<p>//todo</p>
<h2 id="堆排序">堆排序</h2>
<p>堆的性质比较简单，以最大堆为例，父节点必须大于等于子节点的值。另外还有个重要的推论：叶子节点的下标分别是n/2+1，　n/2+2, ｎ/2+3, &hellip;, n。其中，堆排序的最坏运行时间期望是(nlgn)。</p>
<p>实现堆的过程首先是:</p>
<ol>
<li>位置关系和辅助函数</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="font-weight:bold">inline</span> <span style="">int</span>
PARENT(<span style="">int</span> i)
{
    <span style="font-weight:bold">return</span> i / 2;
}

<span style="font-weight:bold">inline</span> <span style="">int</span>
LEFT(<span style="">int</span> i)
{
    <span style="font-weight:bold">return</span> i * 2;
}

<span style="font-weight:bold">inline</span> <span style="">int</span>
RIGHT(<span style="">int</span> i)
{
    <span style="font-weight:bold">return</span> i * 2 + 1;
}

<span style="font-weight:bold">inline</span> <span style="">void</span>
pSwap(<span style="">int</span> &amp;x, <span style="">int</span> &amp;y)
{
    <span style="">int</span> temp = x;
    x = y;
    y = temp;
}
</code></pre></div><ol start="2">
<li>堆的维护过程</li>
</ol>
<p>将指定节点与左右节点相互比较，让三个节点中最大的节点成为父节点。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
SortAlgorithm::maxHeapify(<span style="">int</span> i)
{
    <span style="">int</span> l = LEFT(i);
    <span style="">int</span> r = RIGHT(i);
    <span style="">int</span> lagest;

    <span style="font-weight:bold">if</span> (l &lt; arrayLength() &amp;&amp; a[i-1] &lt; a[l-1])
        lagest = l;
    <span style="font-weight:bold">else</span>
        lagest = i;
    <span style="font-weight:bold">if</span> (r &lt; arrayLength() &amp;&amp; a[lagest-1] &lt; a[r-1])
        lagest = r;

    <span style="font-weight:bold">if</span> (lagest != i) {
        pSwap(a[i-1], a[lagest -1]);
        maxHeapify(lagest);
    }
}
</code></pre></div><ol start="3">
<li>建立堆</li>
</ol>
<p>将一个已有的序列形成堆，利用由下往上的方法建立。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
SortAlgorithm::bulidMaxHeap()
{
    <span style="font-weight:bold">for</span> (<span style="">int</span> i = arrayLength()/2; i &gt;= 1; i--)
        maxHeapify(i);
}

</code></pre></div><ol start="4">
<li>堆排序</li>
</ol>
<p>建成好的堆的根节点是这个序列的最大值，所以，将这个节点先排除出来，然后再进行堆化，可以找出次最大值，依次类推得到一个排好序的队列。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
SortAlgorithm::heapSort()
{
    <span style="font-weight:bold">for</span> (<span style="">int</span> i = arrayLength(); i &gt;= 2; i--) {
        pSwap(a[0], a[i-1]);
        maxHeapify(1);
        len--;
    }
}
</code></pre></div><p>先将最大值根节点与数组的端节点交换，然后将长度减少1，对根节点堆化，重新形成最大堆。</p>
<h2 id="快速排序">快速排序</h2>
<p>快排是一种使用广泛的排序，虽然最坏运行情况是时间复杂度是(n^2)，但是在元素不用的情况下，期望时间复杂度是(nlgn)，并且，快速排序的过程中不用不会用到临时数组作为存储，也就是说，快速排序是原址排序的。快排的思想和归并一样，先将问题进行分解再归并。</p>
<p>快排的代码不长，代码比想象中要神奇。</p>
<p>首先是原址重排：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">int</span>
SortAlgorithm::partitionArray(<span style="">int</span> p, <span style="">int</span> r)
{
    <span style="">int</span> key = a[r-1];
    <span style="">int</span> i = p - 1;

    <span style="font-weight:bold">for</span> (<span style="">int</span> k = p; k &lt;= r; k++) {
        <span style="font-weight:bold">if</span> (a[k-1] &lt; key) {
            i++;
            pSwap(a[i-1], a[k-1]);
        }
    }
    pSwap(a[i+1-1], a[r-1]);
    <span style="font-weight:bold">return</span> i+1;
}
</code></pre></div><p>这个函数的作用就是将(p-&gt;r)的数组进行划分，把数组端点的值作为划分界限，也叫主元。然后递归下去，将每一个小区域进行排序，完成排序。</p>
<p>然后是分治的过程：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
SortAlgorithm::quickSort(<span style="">int</span> p, <span style="">int</span> r)
{
    <span style="font-weight:bold">if</span> (p &lt; r) {
        <span style="">int</span> q = partitionArray(p, r);
        quickSort(p, q-1);
        quickSort(q+1, r);
    }
}
</code></pre></div><p>ps:是先进行分治然后再细分的。</p>
<h2 id="计数排序">计数排序</h2>
<p>基数排序(count sort)也是一种比较神奇的算法，要用到三个数组。时间复杂度为(k+n)。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
SortAlgorithm::countSort()
{
    <span style="font-style:italic">// the size fo array c must
</span><span style="font-style:italic"></span>    <span style="font-style:italic">// bigger than the maximum number
</span><span style="font-style:italic"></span>    <span style="font-style:italic">// in the array a.
</span><span style="font-style:italic"></span>    <span style="">int</span> length = arrayLength();
    <span style="">int</span> b[length], c[length];

    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt; length; i++) {
        c[i] = 0;
        b[i] = 0;
    }


    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 1; i &lt;= length; i++)
        c[a[i-1]]++;

    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 1; i &lt; length; i++)
        c[i] = c[i-1] + c[i];

    <span style="font-weight:bold">for</span> (<span style="">int</span> i = length; i &gt;= 1; i--) {
        b[c[a[i-1]]-1] = a[i-1];
        c[a[i-1]]--;

    }


    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt; length; i++)
        a[i] = b[i];

}
</code></pre></div><p>计数排序的主要用第2，3，4个循环进行排序，其中a[i]对应着序列的值，C[i]对应在数组B中最后填充的位置。每当填充一个，C[i]就会进行减1操作，实际上就是对应在数组B中的位置往前面移动一位。</p>
<h2 id="基数排序">基数排序</h2>
<p>基数排序(radix)在针对数值不大的情况是一种很好的排序算法，其中会用到一种稳定的排序算法作为子算法排序，虽然用到了其他的算法，但是更加重要的其想法。针对数值的相应位进行比较排序。</p>
<p>用到了三个辅助函数:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">int</span>
getBase(<span style="">int</span> n)
{
    <span style="">int</span> d = 0;
    <span style="font-weight:bold">while</span> (n/10 != 0)
        n /= 10, d++;
    <span style="font-weight:bold">return</span> d;
}

<span style="">int</span>
power(<span style="">int</span> base,<span style="">int</span> p)
{
    <span style="font-weight:bold">if</span> (p == 0)
        <span style="font-weight:bold">return</span> 1;
    <span style="font-weight:bold">if</span> (p == 1)
        <span style="font-weight:bold">return</span> base;

    <span style="">int</span> result = power(10, p/2);

    <span style="font-weight:bold">if</span> (p % 2 == 1)
        <span style="font-weight:bold">return</span> base * result * result;
    <span style="font-weight:bold">else</span>
        <span style="font-weight:bold">return</span> result * result;
}

<span style="">int</span>
getNumber(<span style="">int</span> n, <span style="">int</span> d)
{
    <span style="font-weight:bold">if</span> (d == 0)
        <span style="font-weight:bold">return</span> n % 10;
    <span style="font-weight:bold">return</span> (n % power(10, d+1)) / power(10, d);
}
</code></pre></div><p>getBase()获得元素的基数,</p>
<p>power获取以base为底,p为幂值的数值,</p>
<p>getNumber()获取对应位数的值。</p>
<p>然后进行对应数位的排序移位:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
SortAlgorithm::radixSort()
{
    <span style="">int</span> maxBase = 0;
    <span style="">int</span> d;
    <span style="">int</span> b[arrayLength()];

    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt; arrayLength(); i++) {
        d = getBase(radixArr[i]);
        maxBase = maxBase &gt; d ? maxBase : d;
    }

    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt; maxBase+1; i++) {
        <span style="font-weight:bold">for</span> (<span style="">int</span> j = 0; j &lt; arrayLength(); j++)
            b[j] = getNumber(radixArr[j], i);

        dependInsertSort(b, 0, arrayLength());
    }
}
</code></pre></div><h1 id="数据结构">数据结构</h1>
<h2 id="散列表">散列表</h2>
<h2 id="二叉搜索树">二叉搜索树</h2>
<p>二叉搜索树建立好后就已经是一个排序好的序列了，只要执行中序遍历，就是顺序序列。首先声明这样一个结构体来代表叶节点。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C" data-lang="C"><span style="font-weight:bold">typedef</span> <span style="font-weight:bold">struct</span> treenode {
    treenode(<span style="">int</span> value);
    <span style="">int</span> key;
    <span style="font-weight:bold">struct</span> treenode *left;
    <span style="font-weight:bold">struct</span> treenode *right;
    <span style="font-weight:bold">struct</span> treenode *p; <span style="font-style:italic">//parent
</span><span style="font-style:italic"></span>}node;
</code></pre></div><p>以及用来整合二叉树操作的类，其中包含一个数据来存放树的根节点。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="font-weight:bold">class</span> <span style="font-weight:bold">BinarySearchTree</span>
{
    <span style="font-weight:bold">public</span>:
        BinarySearchTree();
        <span style="">void</span> treeInsert(node *z);
        <span style="">void</span> inorderTreeWalk(node *x);
        node* getRoot();
        node* searchNode(<span style="">int</span> value);
        node* treeMin(node *x);
        node* treeMAX(node *x);
        node* successor(node *x);
        <span style="">void</span> treeDelete(node *z);
        <span style="">void</span> transplant(node* u, node* v);

    <span style="font-weight:bold">private</span>:
        node *root;
};
</code></pre></div><p>二叉搜索树中的删除操作要分情况讨论:</p>
<ol>
<li>如果节点没有孩子节点，那么直接替换该节点为<code>null</code>即可。</li>
<li>如果只有一个孩子，那么用孩子节点进行替换。</li>
<li>如果有两个孩子，那么寻找该节点的后继（顺序序列的下一个值）来代替该节点，并且后继节点一定在该节点的右子树中。</li>
</ol>
<p>首先是要一个辅助过程tansplant来帮助删除，即用<code>u</code>的双亲来代替<code>v</code>的双亲。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
BinarySearchTree::transplant(node *u, node *v)
{
    <span style="font-style:italic">// v -&gt; u
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">if</span> (u-&gt;p == NULL)
        root = v;
    <span style="font-weight:bold">else</span> if (u == u-&gt;p-&gt;left)
        u-&gt;p-&gt;left = v;
    <span style="font-weight:bold">else</span>
        u-&gt;p-&gt;right = v;

    <span style="font-weight:bold">if</span> (v != NULL)
        v-&gt;p = u-&gt;p;
}
</code></pre></div><p>然后就是根据三种情况来删除节点:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
BinarySearchTree::treeDelete(node *z)
{
    <span style="font-weight:bold">if</span> (z-&gt;left == NULL)
        transplant(z, z-&gt;right);

    <span style="font-weight:bold">else</span> if (z-&gt;right == NULL)
        transplant(z, z-&gt;left);

    <span style="font-weight:bold">else</span> {
        node *y = treeMin(z-&gt;right);
        <span style="font-weight:bold">if</span> (y-&gt;p != z) {
            transplant(y, y-&gt;right);
            y-&gt;right = z-&gt;right;
            y-&gt;right-&gt;p = y;
        }

        transplant(z, y);
        y-&gt;left = z-&gt;left;
        y-&gt;left-&gt;p = y;
    }
}
</code></pre></div><h2 id="红黑树">红黑树</h2>
<p>红黑树是一种平衡树，大致意思就是树的节点会分散得比较平均。相比二叉搜索树来说，执行一些动态集合操作比如插入删除，搜索的时候执行会比较快，可以保证最差情况下，动态集合操作的时间复杂度为nlgn。</p>
<p>红黑树的性质：</p>
<ol>
<li>每个节点都是红色或者黑色的。</li>
<li>根节点是黑色的。</li>
<li>每个叶节点都是黑色的(nil)。</li>
<li>如果一个节点是红色的，那么两个子节点都是黑色的。</li>
<li>从某个节点出发，到其叶子节点的简单路径上，所包含的黑色节点相同。</li>
</ol>
<p>所以引申出一颗有n个及诶单的红黑树的高度最高为2lg(n+1)。</p>
<p>实现红黑树的插入操作之前，需要用到一个旋转操作来保持二叉搜索树性质:
<img src="" alt="11">
左旋操作：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
rbtree::LeftRotate(rbnode *x)
{
    rbnode *y = x-&gt;right;
    x-&gt;right = y-&gt;left;

    <span style="font-weight:bold">if</span> (y-&gt;left != NULL)
        y-&gt;left-&gt;p = x;
    y-&gt;p = x-&gt;p;

    <span style="font-weight:bold">if</span> (x-&gt;p == NULL)
        root = y;

    <span style="font-weight:bold">else</span> if (x == x-&gt;p-&gt;left)
        x-&gt;p-&gt;left = y;

    <span style="font-weight:bold">else</span>
        x-&gt;p-&gt;right = x;

    y-&gt;left = x;
    x-&gt;p = y;
}
</code></pre></div><p>右旋操作：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
rbtree::RightRotate(rbnode *y)
{
    rbnode *x = y-&gt;left;
    y-&gt;left = x-&gt;right;

    <span style="font-weight:bold">if</span> (x-&gt;right != NULL)
        x-&gt;right-&gt;p = y;
    x-&gt;p = y-&gt;p;

    <span style="font-weight:bold">if</span> (y-&gt;p == NULL)
        root = x;

    <span style="font-weight:bold">else</span> if (y == y-&gt;p-&gt;left)
        x = y-&gt;p-&gt;left;

    <span style="font-weight:bold">else</span>
        x = y-&gt;p-&gt;right;

    x-&gt;right = y;
    y-&gt;p = x;

}
</code></pre></div><p>然后是插入操作，和二叉搜索树一样，通过和节点比对大小确定插入的位置，但是多出一个把新的节点涂色的过程，新的节点会被涂成红色，方便进行平衡二叉树，插入操作完成后，要对红黑树的性质进行检查，并且修复RBT。</p>
<p>插入操作实现：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
rbtree::RBInsert(rbnode* z)
{
    rbnode *x, *y;
    y = NULL;
    x = root;
    <span style="font-weight:bold">while</span> (x != NULL) {
        y = x;
        <span style="font-weight:bold">if</span> (z-&gt;key &lt; x-&gt;key)
            x = x-&gt;left;
        <span style="font-weight:bold">else</span> x = x-&gt;right;
    }
    z-&gt;p = y;

    <span style="font-weight:bold">if</span> (y == NULL)
        root = z;
    <span style="font-weight:bold">else</span> if (z-&gt;key &lt; y-&gt;key)
        y-&gt;left = z;
    <span style="font-weight:bold">else</span>
        y-&gt;right = z;

    z-&gt;c = RED;
    z-&gt;left = NULL;
    z-&gt;right = NULL;
    RBinsertFixup(z);

}
</code></pre></div><p>新插入的节点是红色，如果此时其父节点也是红色，那么就违反了性质4，因此要进行红黑树的修复操作，红黑树的插入修复有三种情况：
（假定新插入的节点为<code>z</code>，父节点为<code>z.p</code>,叔节点为<code>y</code>）</p>
<ul>
<li><strong>a.</strong> z节点的叔节点y是红色的，那么将z.p和y都着为黑色，z.p.p着为红色，并且将z指向z.p.p</li>
</ul>
<p><img src="" alt="case1"></p>
<ul>
<li><strong>b.</strong> z的叔节点y是黑色，并且z是一个右孩子，那么对z的父节点z.p进行左旋操作。</li>
</ul>
<p><img src="" alt="case2"></p>
<ul>
<li><strong>c.</strong> z的叔节点y是黑色，并且z是一个左孩子，那么就将z.p着为黑色，z.p.p着为红色，对z.p执行右旋操作。</li>
</ul>
<hr>
<p>以上只是针对一边的情况，另外一侧镜像对称操作，下面是修复操作的实现：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
rbtree::RBinsertFixup(rbnode* z)
{
    rbnode *y;

    printf(<span style="font-style:italic">&#34;node : %d %s</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>, z-&gt;key, z-&gt;c ? <span style="font-style:italic">&#34;RED&#34;</span>:<span style="font-style:italic">&#34;BLACK&#34;</span>);
    <span style="font-weight:bold">while</span> (z-&gt;p != NULL &amp;&amp; z-&gt;p-&gt;p != NULL &amp;&amp; z-&gt;p-&gt;c == RED) {
        <span style="font-weight:bold">if</span> (z-&gt;p == z-&gt;p-&gt;p-&gt;left) {
            y = z-&gt;p-&gt;p-&gt;right;
            <span style="font-style:italic">/*case 1*/</span>
            <span style="font-weight:bold">if</span> (y != NULL &amp;&amp; y-&gt;c == RED) { <span style="font-style:italic">//uncle node is red
</span><span style="font-style:italic"></span>                z-&gt;p-&gt;c = BLACK;
                y-&gt;c = BLACK;
                z-&gt;p-&gt;p-&gt;c = RED;
                z = z-&gt;p-&gt;p;
            } <span style="font-weight:bold">else</span>  {
                <span style="font-weight:bold">if</span> (z == z-&gt;p-&gt;right) {
                    <span style="font-style:italic">/*case 2*/</span>
                    z = z-&gt;p;
                    LeftRotate(z);
                }
                <span style="font-style:italic">/*case 3*/</span>
                z-&gt;p-&gt;c = BLACK;
                z-&gt;p-&gt;p-&gt;c =RED;
                RightRotate(z-&gt;p-&gt;p);
            }

        }<span style="font-weight:bold">else</span> {
            y = z-&gt;p-&gt;p-&gt;left;
            <span style="font-weight:bold">if</span> (y != NULL &amp;&amp; y-&gt;c == RED) {
                z-&gt;p-&gt;c = BLACK;
                y-&gt;c = BLACK;
                z-&gt;p-&gt;p-&gt;c = RED;
                z = z-&gt;p-&gt;p;
            } <span style="font-weight:bold">else</span> {
                <span style="font-weight:bold">if</span> (z == z-&gt;p-&gt;left) {
                    z = z-&gt;p;
                    RightRotate(z);
                }
                z-&gt;p-&gt;c = BLACK;
                z-&gt;p-&gt;p-&gt;c = RED;
                LeftRotate(z-&gt;p-&gt;p);

            }
        }
    }
    root-&gt;c = BLACK;
}
</code></pre></div><p>实现删除操作之前，要准备两个辅助函数，一个用来更换父节点，一个用来寻找节点的后继。</p>
<p>首先是transplant将u的父节点的子节点更换为v的操作：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
rbtree::rbTransplant(rbnode *u, rbnode *v)
{
    <span style="font-weight:bold">if</span> (u-&gt;p == NULL)
        root = v;
    <span style="font-weight:bold">else</span> if (u == u-&gt;p-&gt;left)
        u-&gt;p-&gt;left = v;
    <span style="font-weight:bold">else</span>
        u-&gt;p-&gt;right = v;
    <span style="font-weight:bold">if</span> (v != NULL)
        v-&gt;p = u-&gt;p;
}
</code></pre></div><p>寻找某个节点后继即寻找左孩子的右子树：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++">rbnode *
rbtree::minimum(rbnode *x)
{
    <span style="font-weight:bold">while</span> (x-&gt;left != NULL)
        x = x-&gt;left;
    <span style="font-weight:bold">return</span> x;
}
</code></pre></div><p>删除操作也和二叉搜索树想类似，如果只有一个节点就简单删除；否则，寻找后继节点来替代被删除的节点，但是红黑树需要对颜色进行跟踪，如果被替换的节点y原来是黑色，那么就引起了黑高变化，因此会进行红黑树修复操作。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
rbtree::rbDelete(rbnode *z)
{
    rbnode *x, *y = z;
    color origin = y-&gt;c;
    <span style="font-weight:bold">if</span> (z-&gt;left == NULL) {
        x = z-&gt;right;
        rbTransplant(z, z-&gt;right);
    } <span style="font-weight:bold">else</span> if (z-&gt;right == NULL) {
        x = z-&gt;left;
        rbTransplant(z, z-&gt;left);
    } <span style="font-weight:bold">else</span> {
        y = minimum(z-&gt;right);
        origin = y-&gt;c;
        x = y-&gt;right;
        <span style="font-weight:bold">if</span> (y-&gt;p == z) {
            <span style="font-weight:bold">if</span> (x != NULL)
                x-&gt;p = y;
        }
        <span style="font-weight:bold">else</span> {
            rbTransplant(y, y-&gt;right);
            y-&gt;right = z-&gt;right;
            y-&gt;right-&gt;p = y;
        }
        rbTransplant(z, y);
        y-&gt;left = z-&gt;left;
        <span style="font-weight:bold">if</span> (y-&gt;left != NULL)
            y-&gt;left-&gt;p = y;
        y-&gt;c = z-&gt;c;
        free(z);
    }
   <span style="font-weight:bold">if</span> (origin == BLACK)
        rbDeleteFixup(x);
}
</code></pre></div><p>删除修复工作有些复杂，这里没有理解为什么这么做，先记下来：</p>
<ol>
<li>x的兄弟节点w是红色，那么改变w和x.p的颜色，然后对x.p做一次左旋。
<img src="" alt=""></li>
<li>x的兄弟节点w是黑色，且w的两个子节点都是黑色，那么将w着为黑色并且将x指向x.p。</li>
<li>x的兄弟节点w是黑色，且w的左孩子是红色的，w的右孩子是黑色的，那么交换w和w.left的颜色，并且对w执行右旋。</li>
<li>x的兄弟节点w是黑色，且w的右孩子是红色的，那么将w的颜色着为x.p的颜色，w.right和x.p都着为黑色，并且对x.p执行左旋。</li>
</ol>
<p>同样的，以上情况只针对左子树，右子树的处理镜像对称。</p>
<p>删除操作的实现：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
rbtree::rbDeleteFixup(rbnode *x)
{
    rbnode *w;

    <span style="font-weight:bold">while</span> (x != root &amp;&amp; x-&gt;c == BLACK) {
        <span style="font-weight:bold">if</span> (x == x-&gt;p-&gt;left) {
            w = x-&gt;p-&gt;right;
            <span style="font-weight:bold">if</span> (w-&gt;c == RED) { <span style="font-style:italic">//case 1
</span><span style="font-style:italic"></span>                w-&gt;c = BLACK;
                x-&gt;p-&gt;c = RED;
                LeftRotate(x-&gt;p);
                w = x-&gt;p-&gt;right;
            }
            <span style="font-weight:bold">if</span> (w-&gt;left-&gt;c == BLACK &amp;&amp; w-&gt;right-&gt;c == RED) { <span style="font-style:italic">// case 2
</span><span style="font-style:italic"></span>                w-&gt;c = RED;
                x = x-&gt;p;
            } <span style="font-weight:bold">else</span> {
                <span style="font-weight:bold">if</span> (w-&gt;right-&gt;c == BLACK) { <span style="font-style:italic">// case 3
</span><span style="font-style:italic"></span>                    w-&gt;left-&gt;c = BLACK;
                    w-&gt;c = RED;
                    RightRotate(w);
                    w = x-&gt;p-&gt;right;
                }
                <span style="font-style:italic">// case 4
</span><span style="font-style:italic"></span>                w-&gt;c = x-&gt;p-&gt;c;
                x-&gt;p-&gt;c = BLACK;
                w-&gt;right-&gt;c = BLACK;
                LeftRotate(x-&gt;p);
                x = root;
            }
        } <span style="font-weight:bold">else</span> {
            w = x-&gt;p-&gt;left;
            <span style="font-weight:bold">if</span> (w-&gt;c == RED) {
                w-&gt;c = BLACK;
                x-&gt;p-&gt;c = RED;
                RightRotate(x-&gt;p);
                w = x-&gt;p-&gt;left;
            }
            <span style="font-weight:bold">if</span> (w-&gt;left-&gt;c == RED &amp;&amp; w-&gt;right-&gt;c == BLACK) {
                w-&gt;c = RED;
                x = x-&gt;p;
            } <span style="font-weight:bold">else</span> {
                <span style="font-weight:bold">if</span> (w-&gt;left-&gt;c == BLACK) {
                    w-&gt;right-&gt;c = BLACK;
                    w-&gt;c = RED;
                    LeftRotate(w);
                    w = x-&gt;p-&gt;left;
                }
                w-&gt;c = x-&gt;p-&gt;c;
                x-&gt;p-&gt;c = BLACK;
                w-&gt;left-&gt;c = BLACK;
                RightRotate(x-&gt;p);
                x = root;
            }
        }
    }

    x-&gt;c = BLACK;
}
</code></pre></div><h1 id="扩展数据结构">扩展数据结构</h1>
<h2 id="区间树">区间树</h2>
<h2 id="动态统计树">动态统计树</h2>
<h1 id="动态规划">动态规划</h1>
<h2 id="最长公共子序列问题">最长公共子序列问题</h2>
<p>这个问题为了求出两个字符序列xy中最长的公共子序列(LCS)，用i和j分别代表xy的长度，解决这个问题的方法是分别从字符序列的一段开始比较，分成两种情况：</p>
<ol>
<li>如果x[i] == y[j]，那么说明这个字符是公共字符，属于LCS。那么，接下来只要将这个字符加入到LCS中，并且将序列xy的长度进行减１，继续求出剩下序列的LCS。</li>
<li>如果x[i] != y[j]，那么说明x[i-1]和y[j] 或者 x[i]和y[j-1]存在LCS。</li>
</ol>
<p>这样可以得到递归式：</p>
<ul>
<li>当x[i] == y[j]时，C[i][j] = C[i-1][j-1]+1</li>
<li>当x[i] != y[j]时，C[i][j] = max{C[i-1][j], C[i][j-1]}</li>
</ul>
<p>首先定义了一个方向的枚举类型：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="font-weight:bold">enum</span> <span style="font-weight:bold">direction</span> {
    LEFT = 0,
    UP,
    UpperLeft
};
</code></pre></div><p>LCS问题用递归的方法更加容易理解和操作：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-fallback" data-lang="fallback">int
DynamicProgramming::LCSlengthRecursive(int i, int j)
{

    if (i == 0 || j == 0)
        return 0;

    if (strA[i-1] == strB[j-1])
        c[j][i] = LCSlengthRecursive(i-1, j-1) + 1;
    else {
        int x, y;
        x = LCSlengthRecursive(i-1, j);
        y = LCSlengthRecursive(i, j-1);
        c[j][i] = x &gt; y ? x : y;
    }

    return c[j][i];

}
</code></pre></div><p>然后发现决策树里多次重复出现求同样的子问题的情况，那么可以去掉这些重复的操作，进行一下优化。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">int</span>
DynamicProgramming::LCSlengthRecursive(<span style="">int</span> i, <span style="">int</span> j)
{

    <span style="font-weight:bold">if</span> (c[j][i] == 0){
        <span style="font-weight:bold">if</span> (i == 0 || j == 0)
            <span style="font-weight:bold">return</span> 0;

        <span style="font-weight:bold">if</span> (strA[i-1] == strB[j-1])
            c[j][i] = LCSlengthRecursive(i-1, j-1) + 1;
        <span style="font-weight:bold">else</span> {
            <span style="">int</span> x, y;
            x = LCSlengthRecursive(i-1, j);
            y = LCSlengthRecursive(i, j-1);
            c[j][i] = x &gt; y ? x : y;
        }
    }

    <span style="font-weight:bold">return</span> c[j][i];

}
</code></pre></div><p>但是迭代的速度更快：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
DynamicProgramming::LCSlengthIterate()
{
    <span style="">int</span> i = 0, j = 0;

    <span style="font-weight:bold">for</span> (i = 1; i &lt; m; i++)
        c[0][i] = 0;
    <span style="font-weight:bold">for</span> (i = 0; i &lt; n; i++)
        c[i][0] = 0;

    <span style="font-style:italic">/*CASE DILIVER*/</span>
    <span style="font-weight:bold">for</span> (i = 1; i &lt; n; i++)
        <span style="font-weight:bold">for</span> (j = 1; j &lt; m; j++)
            <span style="font-weight:bold">if</span> (strA[j-1] == strB[i-1]) {
                c[i][j] = c[i-1][j-1] + 1;
                b[i][j] = UpperLeft;
            } <span style="font-weight:bold">else</span> if (c[i][j-1] &gt;= c[i-1][j]) {
                c[i][j] = c[i][j-1];
                b[i][j] = LEFT;
            } <span style="font-weight:bold">else</span> {
                c[i][j] = c[i-1][j];
                b[i][j] = UP;
            }
    }

    PrintLCS(b, c, m, n);
}
</code></pre></div><p>这个函数后半部分是做LCS各种情况的派发的，两层for循环，内层代表这个表格的x轴，外层代表表格的y轴，将i和j所指的元素进行比较，如果相同根据第一种情况从子问题中获取最优解，也就是长度分别为<code>i-1</code>和长度为<code>j-1</code>的子序列获取LCS，并且由于ij所指定位置相等，该位置进行自增。数组C用来记录LCS的长度，数组B用来LCS的路径。</p>
<p>在准备输出LCS的时候，想起来要传递两个二维数组，才能递归输出，然后踩到了一个关于<a href="about:blank">二维数组与二级指针转换问题</a>的坑，一种更好的解决办法是把这一部分准备二维数组的操作放入到构造函数内去，并且在析构函数中释放掉：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="font-style:italic">/*constructor*/</span>
DynamicProgramming::DynamicProgramming(string s1, string s2)
: strA(s1), strB(s2), lcs(<span style="font-style:italic">&#34;&#34;</span>) , m(strA.length()+1), n(strB.length()+1)
{
        c = (<span style="">int</span> **) malloc (<span style="font-weight:bold">sizeof</span>(<span style="">int</span> *[m]) * n);

        *b = (direction *)malloc(<span style="font-weight:bold">sizeof</span>(direction) * m * n);
        *c = (<span style="">int</span> *)malloc(<span style="font-weight:bold">sizeof</span>(<span style="">int</span>) * m * n);

        <span style="font-weight:bold">for</span> (<span style="">int</span> y = 1; y &lt; n; y++ ) {
            b[y] = b[y-1] + m;
            c[y] = c[y-1] + m;
        }
}

<span style="font-style:italic">/*destructor*/</span>
DynamicProgramming::~DynamicProgramming()
{
    <span style="font-style:italic">//dtor
</span><span style="font-style:italic"></span>    free(*c);
    free(*b);
    free(c);
    free(b);
}
</code></pre></div><p>。输出递归函数根据数组B所记录的方向进行输出，得到LCS：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
DynamicProgramming::PrintLCS(direction **b, <span style="">int</span> **c, <span style="">int</span> x, <span style="">int</span> y)
{

    <span style="font-weight:bold">if</span> (x == 0 || y == 0)
        <span style="font-weight:bold">return</span> ;

    <span style="font-weight:bold">if</span> (b[y-1][x-1] == UpperLeft) {
        PrintLCS(b, c, x-1, y-1);
        cout &lt;&lt; strB[y-2] &lt;&lt;endl;

    } <span style="font-weight:bold">else</span> if (b[y-1][x-1] == LEFT)
        PrintLCS(b, c, x-1, y);

    <span style="font-weight:bold">else</span>
        PrintLCS(b, c, x, y-1);
}
</code></pre></div><h1 id="贪心算法">贪心算法</h1>
<p>贪心问题是每一步都选择最优解,从而达到最有解的情况，相比于动态规划，其编程复杂性比较低。</p>
<h2 id="活动选择问题">活动选择问题</h2>
<p>该问题是从起始时间和结束时间不同的多个活动中，选取尽量多的活动，那么贪心的运用就是，先将该活动序列以结束时间进行排序，然后依次选择合适的结束时间早的活动，得到最优解。</p>
<p>递归实现：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
ActivitySelect::recursive_selector(<span style="">int</span> k, <span style="">int</span> n)
{
<span style="">int</span> m = k + 1;

<span style="font-weight:bold">while</span> (m &lt; n &amp;&amp; f[k] &gt; s[m])
    m++;
<span style="font-weight:bold">if</span> (m &lt;= n) {
    greedy_sequence.push_back(m);
    recursive_selector(m, n);
}
}
</code></pre></div><p>迭代版本：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
ActivitySelect::iterative_selector(<span style="">int</span> n)
{
<span style="">int</span> k = 1;
greedy_sequence.push_back(k);
<span style="font-weight:bold">for</span> (<span style="">int</span> m = 2; m &lt;= n; m++)
    <span style="font-weight:bold">if</span> (s[m] &gt;= f[k]) {
        greedy_sequence.push_back(m);
        k = m;
    }
}
</code></pre></div><p>为了方便实现并集操作，这里选择将结果的集合用vector来处理。</p>
<h2 id="霍夫曼编码">霍夫曼编码</h2>
<p>霍夫曼编码常用于压缩数据，是在给定字符频率的情况下，获取最优的压缩率，霍夫曼树向左下降就是编码添加0，向右即为1，为了取得较好的压缩率，所以，频率高的关键字应该在接近树根的位置，相应地，频率低的节点应该在叶子节点附近。</p>
<p>其结构体定义也比较简单，二叉树节点中加入键值和频率即可：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="font-weight:bold">typedef</span> <span style="font-weight:bold">struct</span> <span style="font-weight:bold">huffmantree</span>{
    huffmantree() = <span style="font-weight:bold">default</span>;
    huffmantree(<span style="">char</span> c, <span style="">int</span> f) : freq(f), character(c){}
    <span style="">int</span> freq;
    <span style="">char</span> character;
    <span style="font-weight:bold">struct</span> <span style="font-weight:bold">huffmantree</span> *left;
    <span style="font-weight:bold">struct</span> <span style="font-weight:bold">huffmantree</span> *right;
}hfnode;
</code></pre></div><p>因为霍夫曼树每次建立一个新节点都要从需要编码的队列中找出最小的元素，所以，需要完成一个最小堆来减少时间消耗。只需要几个简单的集合操作即可:</p>
<ul>
<li>堆的维护</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
minHeapify(hfnode* a, <span style="">int</span> len, <span style="">int</span> i)
{
    <span style="">int</span> r = _Right(i);
    <span style="">int</span> l = _Left(i) ;
    <span style="">int</span> minimum;

    <span style="font-weight:bold">if</span> (l &lt; len &amp;&amp; a[l-1].freq &lt; a[i-1].freq)
        minimum = l;
    <span style="font-weight:bold">else</span>
        minimum = i;

    <span style="font-weight:bold">if</span> (r &lt; len &amp;&amp; a[r-1].freq &lt; a[minimum-1].freq)
        minimum = r;

    <span style="font-weight:bold">if</span> (minimum != i) {
        myswap(a[minimum-1], a[i-1]);

        minHeapify(a, len, minimum);
    }
}
</code></pre></div><ul>
<li>建立堆</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
buildHeap(hfnode* a, <span style="">int</span> len)
{

    <span style="font-weight:bold">for</span> (<span style="">int</span> i = len/2; i &gt;= 1; i--)
        minHeapify(a, len, i);
}
</code></pre></div><ul>
<li>抽取最小值</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++">hfnode&amp;
extractmin(hfnode* heap, <span style="">int</span> &amp;len)
{
    myswap(heap[0], heap[len-1]);
    len--;
    minHeapify(heap, len, 1);
    <span style="font-weight:bold">return</span> heap[len];
}
</code></pre></div><ul>
<li>插入</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
heapInsert(hfnode* heap, <span style="">int</span> &amp;len, hfnode&amp; z)
{
    heap[len++] = z;
    buildHeap(heap, len+1);
}
</code></pre></div><p>建立霍夫曼树的过程就是，首先尽量选频率小的元素作为叶子，然后分配一个新的节点作为它们的父节点，该父节点的频率值为子节点频率和，最后将该父节点重新放回最小堆，循环再次从堆中抽取两个最小值，形成下一个节点，依次类推知道得到最后的根节点，其频率应该为1。</p>
<p>实现如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++">hfnode *
Huffmantranslations::buildHuffmanTree(hfnode arr[], <span style="">int</span> len)
{
    <span style="">int</span> n = len;

    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 1; i &lt; n; i++) {
            hfnode x = extractmin(arr, len);
            hfnode y = extractmin(arr, len);
            hfnode *z = <span style="font-weight:bold">new</span> hfnode;
            z-&gt;left = &amp;x;
            z-&gt;right = &amp;y;
            z-&gt;freq = x.freq + y.freq;
            heapInsert(arr, len, *z);
            printf(<span style="font-style:italic">&#34;%d %d</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>, x.freq, y.freq);
    }
    <span style="font-weight:bold">return</span> &amp;arr[0];
}
</code></pre></div><h1 id="高级数据结构">高级数据结构</h1>
<h2 id="b树">B树</h2>
<p>B树主要的用途是用来进行优化磁盘操作，减少慢速设备和快速设备之间的速度差是很有必要的，所以在该算法中会有出现磁盘操作，虽然没有进行对应的操作，但是有必要知道什么时候进行读写，磁盘页只会在内存中留着极少数量。
性质：</p>
<ol>
<li>
<p>节点属性</p>
<ul>
<li>x.n代表存储在节点x中的节点个数</li>
<li>x.key[i]以非降序排放</li>
<li>x.leaf判断是否为叶子节点</li>
<li>有x.n+1个指针(x.c)指向该节点的孩子节点</li>
</ul>
</li>
<li>
<p>节点x.key[i]分割孩子节点的关键字</p>
</li>
<li>
<p>每个节点的最大和最小关键字又最小度数(minumum degree)决定，最小度数为２时是最简单的Ｂ树，即２－３－４树。</p>
<ul>
<li>除了根节点，每个节点必须有t-1个关键字</li>
<li>除了根节点，每个节点必须有t个孩子节点</li>
<li>树非空，根节点必须要有关键字</li>
<li>每个节点最多2t-1个关键字，即有2t个孩子节点</li>
</ul>
</li>
</ol>
<p>在实现过程中，自己有用到<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">算法可视化</a>进行辅助编写，但是里面的概念和书上有点不同，比如t=2时，应该选中max.degree=4，并且选中Preemtive Split优先分离选项。</p>
<p>首先是树的节点定义：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="font-weight:bold">typedef</span> <span style="font-weight:bold">struct</span> <span style="font-weight:bold">btreenode</span>
{
    <span style="">int</span> n;  <span style="font-style:italic">// the number of key
</span><span style="font-style:italic"></span>    <span style="">bool</span> leaf;
    <span style="font-style:italic">/* both key and child pointer need to be allocated according to the value __n__ */</span>
    <span style="font-weight:bold">struct</span> <span style="font-weight:bold">btreenode</span> **cp; <span style="font-style:italic">// point to the child pointer
</span><span style="font-style:italic"></span>    <span style="">void</span> ** diskpage;
    <span style="">char</span> *key; <span style="font-style:italic">// point to the key area
</span><span style="font-style:italic"></span>}bnode;
</code></pre></div><p>刚开始定义的时候，以为关键字大小是变化的，需要进行动态分配，实际上使用数组会方便很多，但是要提前知道度数。</p>
<p>然后是<code>创建B树的根节点</code>，二叉树是向下进行增长的，新的节点加入到叶子节点然后再进行其他的操作，而<code>Ｂ树是向上进行增长的</code>，所以，除了前面几个节点是叶子节点，并且所有的树高都是同样的。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++">bnode*
Btree::BTree_Create()
{
    bnode* x = <span style="font-weight:bold">new</span> bnode;
    x-&gt;leaf = true;
    x-&gt;n = 0;

    x-&gt;key = <span style="font-weight:bold">new</span> <span style="">char</span>[2 * t - 1 + 1];
    x-&gt;cp = <span style="font-weight:bold">new</span> bnode*[2 * t + 1]; <span style="font-style:italic">// abort the first element of the array;
</span><span style="font-style:italic"></span>
    DiskRead(x);
    root = x;
    <span style="font-weight:bold">return</span> x;
}
</code></pre></div><p>然后是进行<code>插入操作</code>，但是在这之前需要完成一个分类节点的辅助函数，当一个节点的最大元素数量大于2t-1的时候，那么就需要进行分裂操作，将该节点变为两个各含t-1个元素的节点，并且将中间关键字提升到父节点去。
分列函数的实现:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
Btree::BTree_SplitChild(bnode *x, <span style="">int</span> i)
{

    bnode* z = Allocate_Node();
    bnode* y = (x-&gt;cp)[i];

    z-&gt;leaf = y-&gt;leaf;
    z-&gt;n = t-1;


    <span style="font-weight:bold">for</span> (<span style="">int</span> j = 1; j &lt;= t-1; j++)
        (z-&gt;key)[j] = (y-&gt;key)[j+t]; <span style="font-style:italic">// j+t = j + (t-1) + 1
</span><span style="font-style:italic"></span>

    <span style="font-weight:bold">if</span> (y-&gt;leaf == false)
        <span style="font-weight:bold">for</span> (<span style="">int</span> j = 1; j &lt;= t; j++)
            (z-&gt;cp)[j] = (y-&gt;cp)[j+t];
    y-&gt;n = t-1;


    <span style="font-weight:bold">for</span> (<span style="">int</span> j = x-&gt;n + 1; j &gt;= i+1; j--)
        (x-&gt;cp)[j+1] = (x-&gt;cp)[j];
    (x-&gt;cp)[i+1] = z;

    <span style="font-weight:bold">for</span> (<span style="">int</span> j = x-&gt;n; j &gt;= i; j--)
        (x-&gt;key)[j+1] = (x-&gt;key)[j];
    (x-&gt;key)[i] = (y-&gt;key)[t];


    printf(<span style="font-style:italic">&#34;split-&gt;[%c]</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>, (x-&gt;key)[i]);
    x-&gt;n++;


    DiskWrite(x);
    DiskWrite(y);
    DiskWrite(z);
}
</code></pre></div><p>参数i的作用是定位孩子节点，(x-&gt;key)[i]是提升子节点关键字的位置，(y-&gt;key)[t]用t进行定位，得到需要被提升的关键字。除此之外，如果不是叶子情况，那么孩子节点都需要进行对应赋值。</p>
<p>然后开始<code>插入过程</code>：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
Btree::BTree_Insert(<span style="">char</span> key)
{

    bnode* r = root;
    <span style="font-weight:bold">if</span> (r-&gt;n == 2 * t - 1) {
        bnode *s = Allocate_Node();
        root = s;
        s-&gt;leaf = false;
        s-&gt;n = 0;
        (s-&gt;cp)[1] = r;
        BTree_SplitChild(s,1);
        BTree_Insert_NONFULL(s, key);
    }
    <span style="font-weight:bold">else</span>
        BTree_Insert_NONFULL(r, key);

}
</code></pre></div><p>因为Ｂ树是向上进行增长的，所以，分裂一般是在根节点发生的。比如，最小度数t=２的情况，根节点当插入了３个值准备进行第４个值的插入操作的时候，就会分配一个新的节点作为新的根节点，分裂，并且提升子关键字。</p>
<p>保证x.leaf正确性的理由是，从Insert函数分配的新根节点都是false值，但是在split函数中的是通过兄弟节点进行赋值才获取的值，也就是说，只有叶子节点的兄弟节点才是叶子节点。</p>
<p>完成这些准备后，才开始真正的<code>插入操作</code>过程：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++"><span style="">void</span>
Btree::BTree_Insert_NONFULL(bnode *x, <span style="">char</span> k)
{

    <span style="">int</span> i = x-&gt;n;
    <span style="font-weight:bold">if</span> (x-&gt;leaf == true) {

        <span style="font-weight:bold">while</span> (i &gt;= 1 &amp;&amp; k &lt; (x-&gt;key)[i]) {
            (x-&gt;key)[i+1] = (x-&gt;key)[i];
            i--;
        }

        printf(<span style="font-style:italic">&#34;insert : %c</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>, k);

        (x-&gt;key)[i+1] = k;
        x-&gt;n++;

        DiskWrite(x);

    } <span style="font-weight:bold">else</span> {
        <span style="font-weight:bold">while</span> (i &gt;= 1 &amp;&amp; k &lt; (x-&gt;key)[i])
            i--;
        i += 1;

        DiskRead((x-&gt;cp)[i]);

        <span style="font-weight:bold">if</span> ((x-&gt;cp)[i]-&gt;n == 2 * t - 1) {
            BTree_SplitChild(x, i);
            <span style="font-weight:bold">if</span> (k &gt; (x-&gt;key)[i]) <span style="font-style:italic">// the new key comes from child node
</span><span style="font-style:italic"></span>                i += 1;
        }

        BTree_Insert_NONFULL((x-&gt;cp)[i], k);
    }
}
</code></pre></div><p>由此可见，插入函数是不断地把关键字插入到叶子节点去，如果某个叶子节点满了的话，那么就会分裂该节点并且，提升一个关键字到父节点，如果该父节点也满了，那么递归进行分裂。在执行分裂后有一个<code>小细节</code>，如果从子节点提升的关键字比ｉ小，那么就要把这个节点插入到这个节点的右孩子中去，所以ｉ执行了加１的操作。</p>
<p>然后是<code>删除操作</code>了：
书上没有给出删除操作的伪代码，但是给出了不同情况的解决办法，我以我的理解对这些情况进行了扩充：</p>
<ol>
<li>如果关键字ｋ在叶子节点ｘ中，<code>并且该节点的元素不少于t-1</code>，那么简单从ｘ中删除该关键字。</li>
<li>如果关键字ｋ<code>在</code>内部节点ｘ中，那么分三种情况:
<ul>
<li><strong>a.</strong>　如果该节点的左子节点包含大于等于<code>t</code>个关键字，那么可以从左子节点中找出前驱<code>k'</code>（最后一个元素）代替ｘ节点中的ｋ，然后递归删除左子节点中的<code>k'</code>。</li>
<li><strong>b.</strong>　如果左子节点只含有<code>t-1</code>个关键字，那么从右子节点中找出后继<code>k'</code>（第一个元素），然后递归删除<code>k'</code>。</li>
<li><strong>c.</strong>　如果左右子节点的关键字都是<code>t-1</code>个关键字，那么将<code>k</code>和右子节点都合并到左子节点，左子节点中的元素变为 2t-1　，然后释放右子节点并且递归删除<code>k</code>。</li>
</ul>
</li>
<li>如果不在内部节点ｘ（叶子节点）中，那么需要在子节点中去删除,又可以分成两种情况：
<ul>
<li><strong>a.</strong>　如果孩子节点只有ｔ-1个关键字，但是<code>前一个或者后一个子节点</code>拥有至少<code>t</code>个关键字，那么就需要借一个关键字，也就是ｘ中的关键字<code>k1</code>下降到孩子节点中，然后从其他子节点中去偷取一个关键字<code>k2</code>，并且删除原来的<code>k2</code>关键字。</li>
<li><strong>b.</strong>　如果相邻的子节点也都是只含有<code>t-1</code>关键字，那就要进行合并存在<code>k</code>的节点和任意一个节点，并且从<code>x</code>中下降一个关键字到新节点去，然后再简单删除关键字<code>k</code>。</li>
</ul>
</li>
</ol>
<p>下面是<code>删除操作</code>的实现：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-C++" data-lang="C++">

<span style="">int</span>
Btree::BTree_Delete(bnode* x, <span style="">char</span> k)
{
    <span style="">int</span> j = 1;
    <span style="font-style:italic">// find k;
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">while</span> (j &lt;= x-&gt;n &amp;&amp; k &gt; (x-&gt;key)[j])
        j++;

    <span style="font-style:italic">/** case 1: key &#39;k&#39; is in the node x, and node x is a leaf node*/</span>

    <span style="font-weight:bold">if</span> (x-&gt;leaf &amp;&amp; x-&gt;n &gt; t-1) {
        printf(<span style="font-style:italic">&#34;case 1</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>);
        j += 1;
        <span style="font-style:italic">// left shift
</span><span style="font-style:italic"></span>        <span style="font-weight:bold">while</span> (j &lt;= x-&gt;n) {
            (x-&gt;key)[j-1] = (x-&gt;key)[j];
            j++;
        }
        x-&gt;n--;
        <span style="font-style:italic">// set nil
</span><span style="font-style:italic"></span>        <span style="font-weight:bold">while</span> ((j-1) &lt; 2 * t ) {
            (x-&gt;key)[j-1] = 0;
            j++;
        }
        printf(<span style="font-style:italic">&#34;remove [%c]</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>, k);
        DiskWrite(x);
        <span style="font-weight:bold">return</span> 0;

    } <span style="font-weight:bold">else</span> if (k == (x-&gt;key)[j] &amp;&amp; !(x-&gt;leaf)) {


    <span style="font-style:italic">/** case 2: node x is not a leaf node, it need keep the number of elements greater than t-1*/</span>

        bnode* y = (x-&gt;cp)[j];
        bnode* z = (x-&gt;cp)[j+1];

        DiskRead(y);
        DiskRead(z);


        <span style="font-weight:bold">if</span> (y-&gt;n &gt;= t) {


    <span style="font-style:italic">/** case 2a: y node &gt;= t-1 + 1, the precursor replaces the x-&gt;key.*/</span>


            printf(<span style="font-style:italic">&#34;precursor: %c</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>, (y-&gt;key)[y-&gt;n]);
            (x-&gt;key)[j] = (y-&gt;key)[y-&gt;n];
            BTree_Delete(y, (y-&gt;key)[y-&gt;n]);


        } <span style="font-weight:bold">else</span> <span style="font-weight:bold">if</span> (z-&gt;n &gt;= t) {


    <span style="font-style:italic">/** case 2b: z node &gt;= t-1 +1, the successor replaces the x-&gt;key.*/</span>


            printf(<span style="font-style:italic">&#34;successor: %c</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>, (z-&gt;key)[1]);
            (x-&gt;key)[j] = (z-&gt;key)[1];
            BTree_Delete(z, (z-&gt;key)[1]);


        } <span style="font-weight:bold">else</span> {


    <span style="font-style:italic">/** case 2c: both y and z don&#39;t have extra key, merge k and z into node
</span><span style="font-style:italic">    y, and simply delete k in the node z finally.*/</span>
            printf(<span style="font-style:italic">&#34; case 2c  </span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>);
            <span style="">int</span> i;

            <span style="font-style:italic">//merge k into y
</span><span style="font-style:italic"></span>            (y-&gt;key)[y-&gt;n+1] = k;
            y-&gt;n += 1;

            <span style="font-style:italic">//merge node z into y
</span><span style="font-style:italic"></span>            <span style="font-weight:bold">for</span> (i = 1; i &lt;= t-1; i++)
                (y-&gt;key)[y-&gt;n+i] = (z-&gt;key)[i];
            <span style="font-weight:bold">for</span> (i = 1; i &lt;= t; i++)
                (y-&gt;cp)[y-&gt;n+i+1] = (z-&gt;cp)[i];
            y-&gt;n = 2 * t - 1;
            <span style="font-weight:bold">delete</span> z;
            <span style="font-style:italic">//deleting key is in the node x
</span><span style="font-style:italic"></span>            <span style="font-weight:bold">for</span> (i = j; i &lt;= x-&gt;n; i++)
                (x-&gt;key)[i] = (x-&gt;key)[i+1];
            (x-&gt;key)[x-&gt;n] = 0;
            <span style="font-weight:bold">for</span> (i = j+1; i &lt;= x-&gt;n+1; i++)
                (x-&gt;cp)[i] = (x-&gt;cp)[i+1];
            (x-&gt;key)[x-&gt;n+1] = NULL;
            x-&gt;n--;

            <span style="font-weight:bold">if</span> (x-&gt;n == 0) {
                <span style="font-weight:bold">delete</span> x;
                root = y;
            }

            <span style="font-style:italic">//deleting key is in the node y
</span><span style="font-style:italic"></span>            BTree_Delete(y, k);


            DiskWrite(y);
            DiskWrite(z);
        }
    } <span style="font-weight:bold">else</span> {
            <span style="font-style:italic">/** case 3: the key isn&#39;t in the node, it need to
</span><span style="font-style:italic">            recursively find the corresponding key */</span>


            printf(<span style="font-style:italic">&#34;case 3 </span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>);
            bnode *ch;
            <span style="">int</span> r;

            <span style="font-style:italic">//find the node recursively
</span><span style="font-style:italic"></span>            <span style="font-weight:bold">if</span> (k != (x-&gt;key)[j])
            {
                <span style="font-style:italic">// it will return when the node
</span><span style="font-style:italic"></span>                <span style="font-style:italic">// does have the key.
</span><span style="font-style:italic"></span>
                ch = (x-&gt;cp)[j];

                r = BTree_Delete(ch, k);
                <span style="font-weight:bold">if</span> (r == 0)
                    <span style="font-weight:bold">return</span> 0;
            } <span style="font-weight:bold">else</span>
                <span style="font-weight:bold">return</span> j;



            bnode* pre = (x-&gt;cp)[j-1];
            bnode* nxt = (x-&gt;cp)[j+1];

            DiskRead(ch);
            DiskRead(pre);
            DiskRead(nxt);

            printf(<span style="font-style:italic">&#34;p: %p</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>, nxt);

            <span style="font-style:italic">/** case 3a: node doesn&#39;t have enough key,
</span><span style="font-style:italic">            steeling key from brother node */</span>
            <span style="font-weight:bold">if</span> (pre &amp;&amp; pre-&gt;n &gt;= t) {

                printf(<span style="font-style:italic">&#34;case 3a1</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>);
                <span style="font-weight:bold">for</span> (<span style="">int</span> i = r; i &gt; 1; i--)
                    (ch-&gt;key)[i] = (ch-&gt;key)[i-1];

                (ch-&gt;key)[1] = (x-&gt;key)[j-1];

                (x-&gt;key)[j-1] = (pre-&gt;key)[pre-&gt;n];
                BTree_Delete(pre, (pre-&gt;key)[pre-&gt;n]);
                DiskWrite(ch);
                DiskWrite(pre);

            } <span style="font-weight:bold">else</span> if (nxt &amp;&amp; nxt-&gt;n &gt;= t) {

                printf(<span style="font-style:italic">&#34;case 3a2</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>);
                <span style="font-weight:bold">for</span> (<span style="">int</span> i = r; i &lt; nxt-&gt;n; i++)
                    (ch-&gt;key)[i] = (ch-&gt;key)[i+1];


                (ch-&gt;key)[nxt-&gt;n] = (x-&gt;key)[j];

                (x-&gt;key)[j] = (nxt-&gt;key)[1];
                BTree_Delete(nxt, (nxt-&gt;key)[1]);
                DiskWrite(ch);
                DiskWrite(nxt);
            } <span style="font-weight:bold">else</span> {

                <span style="font-style:italic">/** case 3b: both of the brother node haven&#39;t
</span><span style="font-style:italic">                enough key, steeling key from the parent node*/</span>

                printf(<span style="font-style:italic">&#34;case 3c</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>);

                <span style="font-weight:bold">for</span> (<span style="">int</span> i = r; i &lt; (t-1)+1-1; i++)
                        (ch-&gt;key)[i] = (ch-&gt;key)[i+1];
                <span style="font-weight:bold">if</span> (pre == NULL) { <span style="font-style:italic">//merge next child node
</span><span style="font-style:italic"></span>
                    (ch-&gt;key)[t] = (x-&gt;key)[j];
                    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 1; i &lt;= t-1; i++)
                        (ch-&gt;key)[i+t] = (nxt-&gt;key)[i];
                    <span style="font-weight:bold">delete</span> nxt;
                    BTree_Delete(x, (x-&gt;key)[j]);
                    DiskWrite(ch);
                } <span style="font-weight:bold">else</span> { <span style="font-style:italic">// merge previous node
</span><span style="font-style:italic"></span>
                    (pre-&gt;key)[t] = (x-&gt;key)[j-1];
                    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 1; i &lt;= t-1-1; i++)
                        (pre-&gt;key)[i+t] = (ch-&gt;key)[i];
                    <span style="font-weight:bold">delete</span> ch;
                    BTree_Delete(x, (x-&gt;key)[j-1]);
                    DiskWrite(pre);

                }



            }
            <span style="font-weight:bold">return</span> 0;


        }



}
</code></pre></div><p>对应情况１，<code>x-&gt;leaf &amp;&amp; x-&gt;n &gt; t-1</code>保证是删除的叶子节点，并且能够进行简单删除。对应情况２，<code>k == (x-&gt;key)[j] &amp;&amp; !(x-&gt;leaf)</code>保证关键字是在节点ｘ内的，并且是个内部节点。情况３用来处理删除叶子节点的关键字，但是没有额外关键字的情况。</p>
<p>写完后发现，实现删除操作的代码过长了，占了200行左右，后来写博客进行总结的时候，发现删除操作和插入操作存在逆向的过程，插入的过程有<code>分裂</code>，而删除的过程有<code>合并</code>的过程，应该可以重写以上代码，分离出一个合并的过程。</p>

        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
            <div class="post-tags">
              <a href="/tags/algorithm/">
                algorithm
              </a>
            </div>
            
          </div>
        </div>
        
          <div class="row">
            <div class="col-xs-12">
              
            </div>
          </div>

          



          
          
          <div style="height: 50px;"></div>
          
          <div class="post-comments">
            <div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://fatwaer.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>

          </div>
          
        

        <div class="site-footer">
  
  
</div>

      </div>
    </div>
  </article>

  

<script>
  
  
    
    
  
</script>

  

</body>

</html>