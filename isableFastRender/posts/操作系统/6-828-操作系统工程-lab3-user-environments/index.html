<!DOCTYPE html>
<html lang="en">
    
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.57.2" />
  <link rel="canonical" href="http://localhost:1313/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6-828-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B-lab3-user-environments/">

  

  
   
   <link rel="shortcut icon" href="/11.jpeg" >
   
  <link rel="manifest" href="/site.webmanifest">

  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/css/prism.css" media="none" onload="this.media='all';">

  
  
  <link rel="stylesheet" type="text/css" href="http://localhost:1313/css/styles.css">

  <style id="inverter" media="none">
    html { filter: invert(100%) }
    * { background-color: inherit }
    img:not([src*=".svg"]), .colors, iframe, .demo-container { filter: invert(100%) }
  </style>

  
  
  <title>6.828-操作系统工程-Lab3:User Environments | fatwaer</title>
</head>

  <body>
    <a href="#main">skip to content</a>
    <svg style="display: none">
  <symbol id="bookmark" viewBox="0 0 40 50">
   <g transform="translate(2266 3206.2)">
    <path style="stroke:currentColor;stroke-width:3.2637;fill:none" d="m-2262.2-3203.4-.2331 42.195 16.319-16.318 16.318 16.318.2331-42.428z"/>
   </g>
  </symbol>

  <symbol id="w3c" viewBox="0 0 127.09899 67.763">
   <text font-size="83" style="font-size:83px;font-family:Trebuchet;letter-spacing:-12;fill-opacity:0" letter-spacing="-12" y="67.609352" x="-26.782778">W3C</text>
   <text font-size="83" style="font-size:83px;font-weight:bold;font-family:Trebuchet;fill-opacity:0" y="67.609352" x="153.21722" font-weight="bold">SVG</text>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m33.695.377 12.062 41.016 12.067-41.016h8.731l-19.968 67.386h-.831l-12.48-41.759-12.479 41.759h-.832l-19.965-67.386h8.736l12.061 41.016 8.154-27.618-3.993-13.397h8.737z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m91.355 46.132c0 6.104-1.624 11.234-4.862 15.394-3.248 4.158-7.45 6.237-12.607 6.237-3.882 0-7.263-1.238-10.148-3.702-2.885-2.47-5.02-5.812-6.406-10.022l6.82-2.829c1.001 2.552 2.317 4.562 3.953 6.028 1.636 1.469 3.56 2.207 5.781 2.207 2.329 0 4.3-1.306 5.909-3.911 1.609-2.606 2.411-5.738 2.411-9.401 0-4.049-.861-7.179-2.582-9.399-1.995-2.604-5.129-3.912-9.397-3.912h-3.327v-3.991l11.646-20.133h-14.062l-3.911 6.655h-2.493v-14.976h32.441v4.075l-12.31 21.217c4.324 1.385 7.596 3.911 9.815 7.571 2.22 3.659 3.329 7.953 3.329 12.892z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m125.21 0 1.414 8.6-5.008 9.583s-1.924-4.064-5.117-6.314c-2.693-1.899-4.447-2.309-7.186-1.746-3.527.73-7.516 4.938-9.258 10.13-2.084 6.21-2.104 9.218-2.178 11.978-.115 4.428.58 7.043.58 7.043s-3.04-5.626-3.011-13.866c.018-5.882.947-11.218 3.666-16.479 2.404-4.627 5.954-7.404 9.114-7.728 3.264-.343 5.848 1.229 7.841 2.938 2.089 1.788 4.213 5.698 4.213 5.698l4.94-9.837z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m125.82 48.674s-2.208 3.957-3.589 5.48c-1.379 1.524-3.849 4.209-6.896 5.555-3.049 1.343-4.646 1.598-7.661 1.306-3.01-.29-5.807-2.032-6.786-2.764-.979-.722-3.486-2.864-4.897-4.854-1.42-2-3.634-5.995-3.634-5.995s1.233 4.001 2.007 5.699c.442.977 1.81 3.965 3.749 6.572 1.805 2.425 5.315 6.604 10.652 7.545 5.336.945 9.002-1.449 9.907-2.031.907-.578 2.819-2.178 4.032-3.475 1.264-1.351 2.459-3.079 3.116-4.108.487-.758 1.276-2.286 1.276-2.286l-1.276-6.644z"/>
  </symbol>

  <symbol id="tag" viewBox="0 0 177.16535 177.16535">
    <g transform="translate(0 -875.2)">
     <path style="fill-rule:evenodd;stroke-width:0;fill:currentColor" d="m159.9 894.3-68.79 8.5872-75.42 77.336 61.931 60.397 75.429-76.565 6.8495-69.755zm-31.412 31.835a10.813 10.813 0 0 1 1.8443 2.247 10.813 10.813 0 0 1 -3.5174 14.872l-.0445.0275a10.813 10.813 0 0 1 -14.86 -3.5714 10.813 10.813 0 0 1 3.5563 -14.863 10.813 10.813 0 0 1 13.022 1.2884z"/>
    </g>
  </symbol>

  <symbol id="balloon" viewBox="0 0 141.73228 177.16535">
   <g transform="translate(0 -875.2)">
    <g>
     <path style="fill:currentColor" d="m68.156 882.83-.88753 1.4269c-4.9564 7.9666-6.3764 17.321-5.6731 37.378.36584 10.437 1.1246 23.51 1.6874 29.062.38895 3.8372 3.8278 32.454 4.6105 38.459 4.6694-.24176 9.2946.2879 14.377 1.481 1.2359-3.2937 5.2496-13.088 8.886-21.623 6.249-14.668 8.4128-21.264 10.253-31.252 1.2464-6.7626 1.6341-12.156 1.4204-19.764-.36325-12.93-2.1234-19.487-6.9377-25.843-2.0833-2.7507-6.9865-7.6112-7.9127-7.8436-.79716-.20019-6.6946-1.0922-6.7755-1.0248-.02213.0182-5.0006-.41858-7.5248-.22808l-2.149-.22808h-3.3738z"/>
     <path style="fill:currentColor" d="m61.915 883.28-3.2484.4497c-1.7863.24724-3.5182.53481-3.8494.63994-2.4751.33811-4.7267.86957-6.7777 1.5696-.28598 0-1.0254.20146-2.3695.58589-5.0418 1.4418-6.6374 2.2604-8.2567 4.2364-6.281 7.6657-11.457 18.43-12.932 26.891-1.4667 8.4111.71353 22.583 5.0764 32.996 3.8064 9.0852 13.569 25.149 22.801 37.517 1.3741 1.841 2.1708 2.9286 2.4712 3.5792 3.5437-1.1699 6.8496-1.9336 10.082-2.3263-1.3569-5.7831-4.6968-21.86-6.8361-33.002-.92884-4.8368-2.4692-14.322-3.2452-19.991-.68557-5.0083-.77707-6.9534-.74159-15.791.04316-10.803.41822-16.162 1.5026-21.503 1.4593-5.9026 3.3494-11.077 6.3247-15.852z"/>
     <path style="fill:currentColor" d="m94.499 885.78c-.10214-.0109-.13691 0-.0907.0409.16033.13489 1.329 1.0675 2.5976 2.0723 6.7003 5.307 11.273 14.568 12.658 25.638.52519 4.1949.24765 14.361-.5059 18.523-2.4775 13.684-9.7807 32.345-20.944 53.519l-3.0559 5.7971c2.8082.76579 5.7915 1.727 8.9926 2.8441 11.562-11.691 18.349-19.678 24.129-28.394 7.8992-11.913 11.132-20.234 12.24-31.518.98442-10.02-1.5579-20.876-6.7799-28.959-.2758-.4269-.57803-.86856-.89617-1.3166-3.247-6.13-9.752-12.053-21.264-16.131-2.3687-.86369-6.3657-2.0433-7.0802-2.1166z"/>
     <path style="fill:currentColor" d="m32.52 892.22c-.20090-.13016-1.4606.81389-3.9132 2.7457-11.486 9.0476-17.632 24.186-16.078 39.61.79699 7.9138 2.4066 13.505 5.9184 20.562 5.8577 11.77 14.749 23.219 30.087 38.74.05838.059.12188.1244.18052.1838 1.3166-.5556 2.5965-1.0618 3.8429-1.5199-.66408-.32448-1.4608-1.3297-3.8116-4.4602-5.0951-6.785-8.7512-11.962-13.051-18.486-5.1379-7.7948-5.0097-7.5894-8.0586-13.054-6.2097-11.13-8.2674-17.725-8.6014-27.563-.21552-6.3494.13041-9.2733 1.775-14.987 2.1832-7.5849 3.9273-10.986 9.2693-18.07 1.7839-2.3656 2.6418-3.57 2.4409-3.7003z"/>
     <path style="fill:currentColor" d="m69.133 992.37c-6.2405.0309-12.635.76718-19.554 2.5706 4.6956 4.7759 9.935 10.258 12.05 12.625l4.1272 4.6202h11.493l3.964-4.4516c2.0962-2.3541 7.4804-7.9845 12.201-12.768-8.378-1.4975-16.207-2.6353-24.281-2.5955z"/>
     <rect style="stroke-width:0;fill:currentColor" ry="2.0328" height="27.746" width="22.766" y="1017.7" x="60.201"/>
    </g>
   </g>
  </symbol>

  <symbol id="info" viewBox="0 0 41.667 41.667">
   <g transform="translate(-37.035 -1004.6)">
    <path style="stroke-linejoin:round;stroke:currentColor;stroke-linecap:round;stroke-width:3.728;fill:none" d="m76.25 1030.2a18.968 18.968 0 0 1 -23.037 13.709 18.968 18.968 0 0 1 -13.738 -23.019 18.968 18.968 0 0 1 23.001 -13.768 18.968 18.968 0 0 1 13.798 22.984"/>
    <g transform="matrix(1.1146 0 0 1.1146 -26.276 -124.92)">
     <path style="stroke:currentColor;stroke-linecap:round;stroke-width:3.728;fill:none" d="m75.491 1039.5v-8.7472"/>
     <path style="stroke-width:0;fill:currentColor" transform="scale(-1)" d="m-73.193-1024.5a2.3719 2.3719 0 0 1 -2.8807 1.7142 2.3719 2.3719 0 0 1 -1.718 -2.8785 2.3719 2.3719 0 0 1 2.8763 -1.7217 2.3719 2.3719 0 0 1 1.7254 2.8741"/>
    </g>
   </g>
  </symbol>

  <symbol id="warning" viewBox="0 0 48.430474 41.646302">
    <g transform="translate(-1.1273 -1010.2)">
     <path style="stroke-linejoin:round;stroke:currentColor;stroke-linecap:round;stroke-width:4.151;fill:none" d="m25.343 1012.3-22.14 37.496h44.28z"/>
     <path style="stroke:currentColor;stroke-linecap:round;stroke-width:4.1512;fill:none" d="m25.54 1027.7v8.7472"/>
     <path style="stroke-width:0;fill:currentColor" d="m27.839 1042.8a2.3719 2.3719 0 0 1 -2.8807 1.7143 2.3719 2.3719 0 0 1 -1.718 -2.8785 2.3719 2.3719 0 0 1 2.8763 -1.7217 2.3719 2.3719 0 0 1 1.7254 2.8741"/>
    </g>
  </symbol>

  <symbol id="menu" viewBox="0 0 50 50">
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="0" x="0"/>
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="20" x="0"/>
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="40" x="0"/>
   </symbol>

   <symbol id="link" viewBox="0 0 50 50">
    <g transform="translate(0 -1002.4)">
     <g transform="matrix(.095670 0 0 .095670 2.3233 1004.9)">
      <g>
       <path style="stroke-width:0;fill:currentColor" d="m452.84 192.9-128.65 128.65c-35.535 35.54-93.108 35.54-128.65 0l-42.881-42.886 42.881-42.876 42.884 42.876c11.845 11.822 31.064 11.846 42.886 0l128.64-128.64c11.816-11.831 11.816-31.066 0-42.9l-42.881-42.881c-11.822-11.814-31.064-11.814-42.887 0l-45.928 45.936c-21.292-12.531-45.491-17.905-69.449-16.291l72.501-72.526c35.535-35.521 93.136-35.521 128.64 0l42.886 42.881c35.535 35.523 35.535 93.141-.001 128.66zm-254.28 168.51-45.903 45.9c-11.845 11.846-31.064 11.817-42.881 0l-42.884-42.881c-11.845-11.821-11.845-31.041 0-42.886l128.65-128.65c11.819-11.814 31.069-11.814 42.884 0l42.886 42.886 42.876-42.886-42.876-42.881c-35.54-35.521-93.113-35.521-128.65 0l-128.65 128.64c-35.538 35.545-35.538 93.146 0 128.65l42.883 42.882c35.51 35.54 93.11 35.54 128.65 0l72.496-72.499c-23.956 1.597-48.092-3.784-69.474-16.283z"/>
      </g>
     </g>
    </g>
  </symbol>

  <symbol id="doc" viewBox="0 0 35 45">
   <g transform="translate(-147.53 -539.83)">
    <path style="stroke:currentColor;stroke-width:2.4501;fill:none" d="m149.38 542.67v39.194h31.354v-39.194z"/>
    <g style="stroke-width:25" transform="matrix(.098003 0 0 .098003 133.69 525.96)">
     <path d="m220 252.36h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
     <path style="stroke:currentColor;stroke-width:25;fill:none" d="m220 409.95h200"/>
     <path d="m220 488.74h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
     <path d="m220 331.15h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
    </g>
   </g>
 </symbol>

 <symbol id="tick" viewBox="0 0 177.16535 177.16535">
  <g transform="translate(0 -875.2)">
   <rect style="stroke-width:0;fill:currentColor" transform="rotate(30)" height="155" width="40" y="702.99" x="556.82"/>
   <rect style="stroke-width:0;fill:currentColor" transform="rotate(30)" height="40" width="90.404" y="817.99" x="506.42"/>
  </g>
 </symbol>
</svg>

    <div class="wrapper">
      <header class="intro-and-nav" role="banner">
  <div>
    <div class="intro">
      <a class="logo" href="/" aria-label="fatwaer home page">
        <img src="http://localhost:1313/images/11.jpeg" alt="">
      </a>
      <p class="library-desc">
        
          Here&rsquo;s fatwaer&rsquo;s blog, recording some technical problems and  notes about open-source courses
        
      </p>
    </div>
    <nav id="patterns-nav" class="patterns" role="navigation">
  <h2 class="vh">Main navigation</h2>
  <button id="menu-button" aria-expanded="false">
    <svg viewBox="0 0 50 50" aria-hidden="true" focusable="false">
      <use xlink:href="#menu"></use>
    </svg>
    Menu
  </button>
  
  <ul id="patterns-list">
  
    <li class="pattern">
      
      
      
      
      <a href="/posts/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Home</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/tags/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Tags</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/about/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">About</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/todo/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Todo</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/index.xml" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">RSS</span>
      </a>
    </li>
  
  </ul>
</nav>
  </div>
</header>
      <div class="main-and-footer">
        <div>
          
  <main id="main">
    <h1>
      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
        <use xlink:href="#bookmark"></use>
      </svg>
      6.828-操作系统工程-Lab3:User Environments
    </h1>

    <div class="date">
      
      
      <strong aria-hidden="true">Publish date: </strong>4-22, 2018
      
        
      
    </div>

    
      <div class="tags">
        <strong aria-hidden="true">Tags: </strong>
        <ul aria-label="tags">
          
            <li>
              <svg class="tag-icon" aria-hidden="true" viewBox="0 0 177.16535 177.16535" focusable="false">
                <use xlink:href="#tag"></use>
              </svg>
              
              <a href="http://localhost:1313/tags/os/">OS</a>
            </li>
          
        </ul>
      </div>
    
    
    
      

  <nav class="toc" aria-labelledby="toc-heading">
    <h2 id="toc-heading">Table of contents</h2>
    <ol>
      
        <li>
          
          
          
          
          <a href="#env-init">
            env_init()
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#env-setup-vm">
            env_setup_vm()
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#region-alloc">
            region_alloc()
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#load-icode">
            load_icode()
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#env-create">
            env_create()
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#env-run">
            env_run()
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#breakpoint%e5%bc%82%e5%b8%b8-3%e5%8f%b7%e4%b8%ad%e6%96%ad%e9%80%9a%e5%b8%b8%e6%98%af%e7%94%a8%e6%9d%a5%e7%bb%99%e8%b0%83%e8%af%95%e5%99%a8%e4%bd%bf%e7%94%a8-%e5%ae%83%e5%85%81%e8%ae%b8%e7%a8%8b%e5%ba%8f%e4%bb%a3%e7%a0%81%e4%b8%b4%e6%97%b6%e6%80%a7%e5%9c%b0%e4%bb%a3%e6%9b%bf%e7%a8%8b%e5%ba%8f%e6%8c%87%e4%bb%a4-%e5%9c%a8jos%e4%b8%ad%e4%bd%bf%e7%94%a8monitor-%e6%9d%a5%e6%89%a7%e8%a1%8c%e5%a4%84%e7%90%86%e5%bc%82%e5%b8%b8">
            breakpoint异常，3号中断通常是用来给调试器使用，它允许程序代码临时性地代替程序指令。在JOS中使用monitor()来执行处理异常。
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#trap-init">
            trap_init()
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#trap-dispatch">
            trap_dispatch()
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#syscall">
            syscall()
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#page-fault-handler">
            page_fault_handler()
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#user-mem-check">
            user_mem_check
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#sys-cputs">
            sys_cputs()
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#debuginfo-eip">
            debuginfo_eip()
          </a>
        </li>
      
    </ol>
  </nav>


    

    

<blockquote>
<p>4月22日 - 5月2日</p>
</blockquote>

<h1 id="part-a">PART A</h1>

<p>这章的练习将会取实现一些基础的用户模式下的环境，也就是进程。在这章，创建一个用户环境，读取程序镜像并且运行。
这是关于这章节代码文件的介绍</p>

<pre><code>inc/env.h   Public definitions for user-mode environments
    trap.h  Public definitions for trap handling
    syscall.h   Public definitions for system calls from user environments to the kernel
    lib.h   Public definitions for the user-mode support library
kern/env.h   Kernel-private definitions for user-mode environments
    env.c   Kernel code implementing user-mode environments
    trap.h  Kernel-private trap handling definitions
    trap.c  Trap handling code
    trapentry.S Assembly-language trap handler entry-points
    syscall.h   Kernel-private definitions for system call handling
    syscall.c   System call implementation code
lib/Makefrag    Makefile fragment to build user-mode library, obj/lib/ libjos.a
    entry.S Assembly-language entry-point for user environments
    libmain.c   User-mode library setup code called from entry.S
    syscall.c   User-mode system call stub functions
    console.c   User-mode implementations of putchar and getchar, providing console I/O
    exit.c  User-mode implementation of exit
    panic.c User-mode implementation of panic
user/   *   Various test programs to check kernel lab 3 code

</code></pre>

<h1 id="内联汇编">内联汇编</h1>

<p>简单描述:</p>

<pre><code>__asm__(汇编语句模板: 输出部分: 输入部分: 破坏描述部分)
</code></pre>

<p><a href="https://blog.csdn.net/pbymw8iwm/article/details/8227839">具体详情</a></p>

<h1 id="文件概述">文件概述</h1>

<p>在文件<code>inc/env.h</code>中定义了<code>Env</code>结构体，用来存储一些关于用户环境(进程)的结构体。</p>

<pre><code class="language-C">struct Env {
    struct Trapframe env_tf;    // Saved registers
    struct Env *env_link;       // Next free Env
    envid_t env_id;         // Unique environment identifier
    envid_t env_parent_id;      // env_id of this env's parent
    enum EnvType env_type;      // Indicates special system environments
    unsigned env_status;        // Status of the environment
    uint32_t env_runs;      // Number of times environment has run

    // Address space
    pde_t *env_pgdir;       // Kernel virtual address of page dir
};

</code></pre>

<p>在这个结构体中，<code>env_status</code>用来指示当前进程的状态，有以下几种定义在一个枚举类型里面。</p>

<pre><code class="language-C">enum {
    ENV_FREE = 0,
    ENV_DYING,
    ENV_RUNNABLE,
    ENV_RUNNING,
    ENV_NOT_RUNNABLE
};

</code></pre>

<p>文件<code>kern/env.c</code>文件中，有三个文件域的定义。</p>

<pre><code class="language-C">struct Env *envs = NULL;        // All environments
struct Env *curenv = NULL;      // The current env
static struct Env *env_free_list;   // Free environment list

</code></pre>

<p><code>envs</code>指向保存所有<code>Env</code>结构体的内存页，并且指向虚拟内存<code>UTOP</code>。</p>

<p><code>curenv</code>是字面意思，指向当前执行的进程。</p>

<p><code>env_free_list</code>是一个链表表头，类似之前的<code>page_free_list</code>。</p>

<h1 id="练习1">练习1</h1>

<blockquote>
<p>分配NENV个Env结构体，并且用envs指针指向它们</p>
</blockquote>

<hr />

<pre><code class="language-C">    envs = (struct Env *)boot_alloc(NENV * sizeof(struct Env));
    memset(envs, 0, NENV * sizeof(struct Env));

    boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U | PTE_P);
</code></pre>

<h1 id="练习2">练习2</h1>

<blockquote>
<p>创建并且运行进程</p>
</blockquote>

<p>完成以下函数:</p>

<pre><code>env_init()
    Initialize all of the Env structures in the envs array and add them to the 
    env_free_list. Also calls env_init_percpu, which configures the 
    segmentation hardware with separate segments for privilege level 0 (
    kernel) and privilege level 3 (user).
env_setup_vm()
    Allocate a page directory for a new environment and initialize the kernel 
    portion of the new environment's address space.
region_alloc()
    Allocates and maps physical memory for an environment
load_icode()
    You will need to parse an ELF binary image, much like the boot loader 
    already does, and load its contents into the user address space of a new 
    environment.
env_create()
    Allocate an environment with env_alloc and call load_icode to load an ELF 
    binary into it.
env_run()
    Start a given environment running in user mode.
    As you write these functions, you might find the new cprintf verb %e 
    useful -- it prints a description corresponding to an error code. For 
    example,

r = -E_NO_MEM;
panic(&quot;env_alloc: %e&quot;, r);
will panic with the message &quot;env_alloc: out of memory&quot;.
</code></pre>

<hr />

<h2 id="env-init">env_init()</h2>

<pre><code class="language-C">void
env_init(void)
{
    // Set up envs array
    // LAB 3: Your code here.
    int iter;

    for (iter = NENV - 1; iter &gt;= 0; iter--) { // reversal order
        envs[iter].env_id = 0;
        envs[iter].env_status = ENV_FREE;
        envs[iter].env_link = env_free_list;
        env_free_list = &amp;envs[iter];
    }

    // Per-CPU part of the initialization
    env_init_percpu();

}
</code></pre>

<p><strong>BUG:这里迭代变量iter是自减，自己之前在这里习惯性的写的自增</strong></p>

<h2 id="env-setup-vm">env_setup_vm()</h2>

<pre><code class="language-C">static int
env_setup_vm(struct Env *e)
{
    int i;
    struct PageInfo *p = NULL;

    // Allocate a page for the page directory
    if (!(p = page_alloc(ALLOC_ZERO)))
        return -E_NO_MEM;

    
    // LAB 3: Your code here.
    e-&gt;env_pgdir = (pte_t *)page2kva(p);
    p-&gt;pp_ref++;

    /* copy structs to UTOP*/
    memcpy(e-&gt;env_pgdir, kern_pgdir, PGSIZE);

    // UVPT maps the env's own page table read-only.
    // Permissions: kernel R, user R
    e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;

    return 0;
}
</code></pre>

<h2 id="region-alloc">region_alloc()</h2>

<pre><code class="language-C">static void
region_alloc(struct Env *e, void *va, size_t len)
{
    // LAB 3: Your code here.
    // (But only if you need it for load_icode.)
    //
    // Hint: It is easier to use region_alloc if the caller can pass
    //   'va' and 'len' values that are not page-aligned.
    //   You should round va down, and round (va + len) up.
    //   (Watch out for corner-cases!)
    uintptr_t va_beg = ROUNDDOWN((uint32_t)va, PGSIZE);
    uintptr_t va_end = ROUNDUP((uint32_t)(va+len), PGSIZE);
    uintptr_t iter;
    
    for (iter = va_beg; iter &lt; va_end; iter += PGSIZE) {  /* maps each page to pa */    
        struct PageInfo *p;
        if (!(p = page_alloc(ALLOC_ZERO))) 
            panic(&quot;lack of free pages&quot;);

        if ((page_insert(e-&gt;env_pgdir, p, (void *)iter, PTE_P | PTE_U | PTE_W)) == -E_NO_MEM)
            panic(&quot;lack memmory&quot;);
    
    }

}

</code></pre>

<p><strong>BUG:在这设置permission的时候，笔误将PTE_P | PTE_U | PTE_W 写成 PTE_P | PTE_P | PTE_W 。导致在env_pop_tf()执行汇编指令iret的时候，无法进入用户模式，系统重启</strong></p>

<h2 id="load-icode">load_icode()</h2>

<pre><code class="language-C">static void
load_icode(struct Env *e, uint8_t *binary)
{
    // LAB 3: Your code here.
    /* user mode */
    lcr3(PADDR(e-&gt;env_pgdir));
    
    struct Elf *elf = (struct Elf *)binary;

    /* check file format */
    if (elf-&gt;e_magic != ELF_MAGIC) 
        panic(&quot;load_icode() : format error &quot;);
    
    if (elf-&gt;e_entry == 0) 
        panic(&quot;load_icode() : ELF file loads failed&quot;);

    e-&gt;env_tf.tf_eip = elf-&gt;e_entry;

    struct Proghdr *ph, *eph;
    ph = (struct Proghdr *)(binary + elf-&gt;e_phoff);
    eph = ph + elf-&gt;e_phnum;

    for (; ph &lt; eph; ph++) {
        if (ph-&gt;p_type == ELF_PROG_LOAD) {  
        region_alloc(e, (void *)(ph-&gt;p_va), ph-&gt;p_memsz);
        
        memcpy((void *)ph-&gt;p_va, (void *)binary + ph-&gt;p_offset, (size_t)(ph-&gt;p_filesz));
    //  memset((void *)ph-&gt;p_va + ph-&gt;p_filesz, 0, ph-&gt;p_memsz - ph-&gt;p_filesz);
        }
    }
    
    lcr3(PADDR(kern_pgdir));
    // Now map one page for the program's initial stack
    // at virtual address USTACKTOP - PGSIZE.
    // LAB 3: Your code here.
    region_alloc(e, (void *)USTACKTOP-PGSIZE, PGSIZE);
}

</code></pre>

<h2 id="env-create">env_create()</h2>

<pre><code class="language-C">void
env_create(uint8_t *binary, enum EnvType type)
{
    // LAB 3: Your code here.
    struct Env * env;
    if (env_alloc(&amp;env, 0) &lt; 0)
        panic(&quot;env_alloc error !&quot;);
    
    
    load_icode(env, binary);    
    env-&gt;env_type = type;
}

</code></pre>

<h2 id="env-run">env_run()</h2>

<pre><code class="language-C">void
env_run(struct Env *e)
{
    if (curenv != NULL &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)
        curenv-&gt;env_status = ENV_RUNNABLE;

    curenv = e;

    curenv-&gt;env_status = ENV_RUNNING;
    curenv-&gt;env_runs++; 
    lcr3(PADDR(curenv-&gt;env_pgdir));
    
    env_pop_tf(&amp;(curenv-&gt;env_tf));
    // Hint: This function loads the new environment's state from
    //  e-&gt;env_tf.  Go back through the code you wrote above
    //  and make sure you have set the relevant parts of
    //  e-&gt;env_tf to sensible values.

    // LAB 3: Your code here.
        
    //panic(&quot;env_run not yet implemented&quot;);
}

</code></pre>

<p>代码完成后应该还是会无限重启，因为，在执行完<code>env_pop_tf</code>的时候会去调用用户自己写的代码，但是会要用到从用户态到内核态的跳转，这部分代码并没有完成。</p>

<pre><code>start (kern/entry.S)
i386_init (kern/init.c)
    cons_init
    mem_init
    env_init
    trap_init (still incomplete at this point)
    env_create
    env_run
    env_pop_tf
</code></pre>

<p>在qemu上运行这个内核，如果调用了成功执行到env_pop_tf的话，基本成功了。此时，内核会去执行一个<code>hello</code>的二进制文件，但是会用到系统调用和使用<code>int</code>中断指令。但是此时的JOS并没有完成用户空间到内核空间的跳转。CPU发现没有办法解决这个的办法，于是生成一个<strong>二重错误异常</strong>，然后继续发现还是没有办法去处理这个错误机制，于是引发<strong>三重错误异常</strong>，这时候，CPU就会要重置，使得整个系统重新启动。这就是现在看到的无限重启的行为。</p>

<p>用<code>make-qemu</code>和<code>make gdb</code>编译出内核，用<code>break env_pop_tf</code>在函数env_pop_tf处设置断点，单步执行，看能否能进入hello.asm中，地址在用户内存空间(0x08000000+)。然后在<code>obj/user/hello.asm</code>中找到<code>sys_cputs</code>中的<code>int $0x30</code>指令。如果成功执行到了这儿，说明之前的代码没有问题。</p>

<h1 id="练习3">练习3</h1>

<p>阅读<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/c09.htm">Chapter 9, Exceptions and Interrupts</a></p>

<hr />

<p>中断是外部发给CPU的信号，而异常是CPU在自己处理命令时候出现的错误。
其中中断分为可屏蔽和不可屏蔽的。</p>

<p>异常也有三种(Faults/Traps/Aborts)，Faults异常是在执行这条指令之前就被指出的错误，但是如果在执行的过程中遇到了faults级的错误，CPU将会让机器保存状态，并且允许被修正重新执行。</p>

<p>第二种是Traps异常，是一种执行完后立即报告的异常，允许程序连续性执行，异常处理的返回地址就是trap指令后的那条。</p>

<p>第三种是Aborts异常，这种异常不报告异常发生的精确位置，也不运行程序继续往下执行。往往是发生了严重的错误，例如硬件错误和不合法的数值。</p>

<pre><code>Table 9-1. Interrupt and Exception ID Assignments

Identifier   Description

0            Divide error
1            Debug exceptions
2            Nonmaskable interrupt
3            Breakpoint (one-byte INT 3 instruction)
4            Overflow (INTO instruction)
5            Bounds check (BOUND instruction)
6            Invalid opcode
7            Coprocessor not available
8            Double fault
9            (reserved)
10           Invalid TSS
11           Segment not present
12           Stack exception
13           General protection
14           Page fault
15           (reserved)
16           Coprecessor error
17-31        (reserved)
32-255       Available for external interrupts via INTR pin 
</code></pre>

<hr />

<p><code>IF</code>(interrput-enable flag)是控制屏蔽外中断的标志位。当IF=0，中断会被屏蔽，IF=1，中断才会被接收。
CLI (Clear Interrupt-Enable Flag) and STI (Set Interrupt-Enable Flag) explicitly alter IF (bit 9 in the flag register).</p>

<p><code>IF</code>标志位被以下三种情况隐性影响：
- <code>PUSHF</code>存储所有flag，包括IF。在栈中的IF，可以被修改。
- 任务切换时，<code>POP</code>和<code>IRET</code>读取flag寄存器，因此，这步操作能修改IF
- 中断通过interrupt gates(?)能自动重置IF，也就关闭外中断。</p>

<hr />

<p>设置段地址的时候也会发生中断，影响程式的执行。通常设置栈区的段的时候通常使用以下这一对指令。</p>

<pre><code class="language-asm">    MOV SS, AX
    MOV ESP, StackTop
</code></pre>

<p>如果这时候发生中断或者异常，SS已经被设置成了AX，而ESP的值还没被传达到，栈指针，SS:ESP在处理中断和异常的时候是不正常的，所以80386CPU在处理这两条指令的时候会屏蔽NMI, INTR, debug exceptions, and single-step traps这些中断。</p>

<h1 id="练习4">练习4</h1>

<blockquote>
<p>编辑trapentry.S和trap.c安装中断向量，宏TRAPHADNLER和TRAPHANDLER_NOEC可以帮助安装向量，中断向量被定义在inc/trap.h中。然后提供一共_alltraps去准备堆栈。在函数trap_init()中初始化idt中断向量数组，并且使用SETGATE去指向相关的函数。</p>
</blockquote>

<hr />

<p>为不同的中断生成入口，两个宏的差别在于是否有<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/s09_10.htm">error code</a>。，如果有的话，硬件会自动将错误信息压栈。如果没有的话，宏<code>TRAPHANDLER_NOEC</code>会压入一个0值。</p>

<pre><code class="language-asm">TRAPHANDLER_NOEC(divid_entry, T_DIVIDE);
TRAPHANDLER_NOEC(debug_entry, T_DEBUG);
TRAPHANDLER_NOEC(nmi_entry, T_NMI);
TRAPHANDLER_NOEC(brkpt_entry, T_BRKPT);
TRAPHANDLER_NOEC(oflow_entry, T_OFLOW);
TRAPHANDLER_NOEC(bound_entry, T_BOUND);
TRAPHANDLER_NOEC(illop_entry, T_ILLOP);
TRAPHANDLER_NOEC(device_entry, T_DEVICE);
TRAPHANDLER(dblflt_entry, T_DBLFLT);
TRAPHANDLER(tss_entry, T_TSS);
TRAPHANDLER(segnp_entry, T_SEGNP);
TRAPHANDLER(stack_entry, T_STACK);
TRAPHANDLER(gpflt_entry, T_GPFLT);
TRAPHANDLER(pgflt_entry, T_PGFLT);
TRAPHANDLER_NOEC(fperr_entry, T_FPERR);
TRAPHANDLER_NOEC(syscall_entry, T_SYSCALL);
</code></pre>

<p><code>_alltraps</code>将所有的寄存器状态保存，压栈。</p>

<pre><code class="language-asm">_alltraps:
    pushl %ds
    pushl %es
    pushal

    mov $GD_KD, %ax
    mov %ax, %es
    mov %ax, %ds

    push %esp

    call trap
</code></pre>

<p>根据<code>Trapframe</code>进行压栈，<code>pushal</code>是压入一些普通寄存器<a href="http://8e3a2546gy1g7y53o1s7hj20hi0c374j.jpg">详情</a></p>

<p><img src="http://py2h8wxnt.bkt.clouddn.com/operating-system/6.828/lab3/stack.png" alt="stack.png" /></p>

<p>根据练习提示，将段寄存器<code>es</code>和<code>ds</code>设置为GDT的kernel数据段，然后将esp压栈，调用trap。</p>

<p>这里直接调用trap就行，调用函数的参数已经在堆栈中，跳转到函数开始的地方就是一个普通的函数调用。</p>

<p>回顾之前的<code>Lab2</code>，在<code>env_run()</code>之前，会执行<code>trap_init()</code>，目的就是为了安装中断向量表。
<code>trap.c/trap_init()</code>中，将<code>idt</code>数组已知中断全部设置好，并将处理这个中断或者异常的handler安装到GDT中的<code>.text</code>域中，并且设置好权限。</p>

<pre><code>void
trap_init(void)
{
    extern struct Segdesc gdt[];

    // LAB 3: Your code here.
    void divid_entry();
    void debug_entry();
    void nmi_entry();
    void brkpt_entry();
    void oflow_entry();
    void bound_entry();
    void illop_entry();
    void device_entry();
    void dblflt_entry();
    void tss_entry();
    void segnp_entry();
    void stack_entry();
    void gpflt_entry();
    void pgflt_entry();
    void fperr_entry();
    void syscall_entry();

    SETGATE(idt[T_DIVIDE], 1, GD_KT, divid_entry, 0);
    SETGATE(idt[T_DEBUG], 1, GD_KT, debug_entry, 3);
    SETGATE(idt[T_NMI], 1, GD_KT, nmi_entry, 0);
    SETGATE(idt[T_BRKPT], 1, GD_KT, brkpt_entry, 3);
    SETGATE(idt[T_OFLOW], 1, GD_KT, oflow_entry, 0);
    SETGATE(idt[T_BOUND], 1, GD_KT, bound_entry, 0);
    SETGATE(idt[T_ILLOP], 1, GD_KT, illop_entry, 0);
    SETGATE(idt[T_DEVICE], 1, GD_KT, device_entry, 0);
    SETGATE(idt[T_DBLFLT], 1, GD_KT, dblflt_entry, 0);
    SETGATE(idt[T_TSS], 1, GD_KT, tss_entry, 0);
    SETGATE(idt[T_SEGNP], 1, GD_KT, segnp_entry, 0);
    SETGATE(idt[T_STACK], 1, GD_KT, stack_entry, 0);
    SETGATE(idt[T_GPFLT], 1, GD_KT, gpflt_entry, 0);
    SETGATE(idt[T_PGFLT], 1, GD_KT, pgflt_entry, 0);
    SETGATE(idt[T_FPERR], 1, GD_KT, fperr_entry, 0);
    SETGATE(idt[T_SYSCALL], 1, GD_KT, syscall_entry, 3);

    // Per-CPU setup 
    trap_init_percpu();
}
</code></pre>

<blockquote>
<p>Q1:What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)</p>
</blockquote>

<p>不同的权限组应该要有不同的解决办法。</p>

<blockquote>
<p>Q2:Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint&rsquo;s code says int 14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint&rsquo;s int 14 instruction to invoke the kernel&rsquo;s page fault handler (which is interrupt vector 14)?</p>
</blockquote>

<p><code>user/softint</code>用户程序中就只有一句:</p>

<pre><code>asm volatile (&quot;int $14&quot;);
</code></pre>

<p>用来产生<code>page fault</code>，但是这是用户程序产生的。一般产生页错误，查看page fault的处理办法<code>page_fault_handler()</code>中<code>env_destroy(curenv);</code>会将这个用户环境销毁。一般用户应该没有这样的权限。</p>

<p>所以对于权限不够的用户，应该产生<code>General protection fault</code>。</p>

<p>This concludes part A of the lab.</p>

<hr />

<h1 id="part-b">PART B</h1>

<p>这一部分解决<strong>Page Faults, Breakpoints Exceptions, System Calls</strong></p>

<p><code>_alltraps</code>会调用traps
<code>traps</code>可以分为四个部分
1. 关闭中断</p>

<pre><code class="language-C">    asm volatile(&quot;cld&quot; ::: &quot;cc&quot;);
    assert(!(read_eflags() &amp; FL_IF));
</code></pre>

<ol>
<li><p>如果是用户模式，复制一份用户栈。</p>

<pre><code>if ((tf-&gt;tf_cs &amp; 3) == 3) {
    assert(curenv);
    curenv-&gt;env_tf = *tf;
    tf = &amp;curenv-&gt;env_tf;
}
last_tf = tf;
</code></pre></li>

<li><p>处理中断</p>

<pre><code>trap_dispatch(tf);
</code></pre></li>

<li><p>如果这个用户环境未被销毁，那么继续执行。</p>

<pre><code>assert(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING);
env_run(curenv);
</code></pre></li>
</ol>

<hr />

<h1 id="练习5-6">练习5 , 6</h1>

<blockquote>
<p>让14号中断调用page_fault_handler()函数</p>

<h2 id="breakpoint异常-3号中断通常是用来给调试器使用-它允许程序代码临时性地代替程序指令-在jos中使用monitor-来执行处理异常">breakpoint异常，3号中断通常是用来给调试器使用，它允许程序代码临时性地代替程序指令。在JOS中使用monitor()来执行处理异常。</h2>

<p><code>page_fault_handler</code>函数中通过<code>fault_va = rcr2()</code>获取页出错的虚拟地址。</p>
</blockquote>

<p>这两个练习都是在<code>trap_dispatch</code>中修改，代码如下。</p>

<pre><code class="language-C">    // Handle page fault exceptions.
    if (tf-&gt;tf_trapno == T_PGFLT) {
        page_fault_handler(tf);
        return ;
    }

    // after int 3 interrupt , this function 
    // uses panic() to output debugger infomations.
    if (tf-&gt;tf_trapno == T_BRKPT) {
        monitor(tf);
        return ;
    }
</code></pre>

<h1 id="challenge">Challenge</h1>

<p>//想做做不出来&hellip;留个思路</p>

<ol>
<li>monitor中执行函数</li>
<li>激活tf栈中的eflags中TF位，开启单步调试</li>
<li>然后使用<code>IRET</code>返回中断，弹栈。
<a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab3/#Exercise-6">optional</a></li>
</ol>

<blockquote>
<p>Q1:The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?</p>
</blockquote>

<p><code>interrupt gate</code>中<code>DPL</code>影响这两种情况，当调用的时候，<code>eflags</code>中的<code>CPL</code>的值大于DPL的时候会产生<code>general protection fault</code>，因为特权等级不够。</p>

<blockquote>
<p>Q2:What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?</p>
</blockquote>

<p>用户不能产生14中断，特权级不够。</p>

<h1 id="练习7">练习7</h1>

<blockquote>
<p>完成系统调用</p>
</blockquote>

<hr />

<p>用户通过系统调用进入内核态，并且保存用户的状态信息，内核执行合适的处理代码，然后恢复到用户态，当然，也需要确定调用是从内核态到用户态还是内核自身调用系统函数。
JOS中系统调用的中断号是0x30，不会由计算机硬件产生，所以需要写好相应的调用代码。</p>

<p>应用程序将会把系统调用的编号和系统调用的参数保存在寄存器中。system call number将会保存在<code>%eax</code>中，接下来最多五个参数分别保存在 <code>%edx</code>, <code>%ecx</code>, <code>%ebx</code>, <code>%edi</code>, <code>%esi</code>中。汇编级的system call函数已经写好在了文件<code>lib/syscall.c</code>中。</p>

<h2 id="trap-init">trap_init()</h2>

<p>在<code>trap_init()</code>中添加相应的handler:</p>

<pre><code class="language-C">    void syscall_entry();

    ...

    ...

    SETGATE(idt[T_SYSCALL], 1, GD_KT, syscall_entry, 3);

</code></pre>

<h2 id="trap-dispatch">trap_dispatch()</h2>

<p>然后在<code>trap_dispatch()</code>中为中断添加调用：</p>

<pre><code class="language-C">    // system call 
    if (tf-&gt;tf_trapno == T_SYSCALL) {
        tf-&gt;tf_regs.reg_eax = syscall(
                tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_edx,
                tf-&gt;tf_regs.reg_ecx, tf-&gt;tf_regs.reg_ebx,
                tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi);
        return ;
    }

</code></pre>

<hr />

<h2 id="syscall">syscall()</h2>

<p>在文件<code>trap.h</code>文件中有一个枚举类型，相当于一个宏定义。</p>

<hr />

<pre><code class="language-C">// Dispatches to the correct kernel function, passing the arguments.
int32_t
syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
    // Call the function corresponding to the 'syscallno' parameter.
    // Return any appropriate return value.
    // LAB 3: Your code here.

    cprintf(&quot;call number:%d  \n&quot;, syscallno);
    switch (syscallno) {

    case SYS_cputs:
        sys_cputs((char *)a1, a2);
        return 0;

    case SYS_cgetc:
        return sys_cgetc();

    case SYS_getenvid:
        return sys_getenvid();

    case SYS_env_destroy:
        return sys_env_destroy(a1);

    default:
        return -E_INVAL;
    }
}
</code></pre>

<h1 id="练习8">练习8</h1>

<hr />

<p>用户程序从这里开始执行，确认号相关信息后跳转到 <code>libmain</code>执行。</p>

<pre><code class="language-asm">.text
.globl _start
_start:
    // See if we were started with arguments on the stack
    cmpl $USTACKTOP, %esp
    jne args_exist

    // If not, push dummy argc/argv arguments.
    // This happens when we are loaded by the kernel,
    // because the kernel does not know about passing arguments.
    pushl $0
    pushl $0

args_exist:
    call libmain
1:  jmp 1b
</code></pre>

<p>将<code>libmain()</code>改成</p>

<pre><code class="language-C">    // LAB 3: Your code here.
    thisenv = envs + ENVX(sys_getenvid());
</code></pre>

<p>ENVX宏定义在<code>env.h</code>文件中。
然后接下来调用用户程序<code>umain</code>和<code>exit()</code>，<code>umain</code>就相当于平时执行的C程序中main函数，<code>exit()</code>执行系统调用函数<code>sys_env_destroy()</code>。</p>

<h1 id="练习9-10">练习9 , 10</h1>

<p>修改kern/trap.c,当内核页错误的时候调用<code>panic</code>，检查tf_cs的低位。
阅读kern/pmap.c中user_mem_assert函数，并且实现user_mem_check函数。
修改kern/syscall.c，检查系统调用的参数。
修改kern/kdebug.c中的debuginfo_eip，调用user_mem_check检查<code>usd</code>,<code>stabs</code>,<code>stabstr</code>。</p>

<hr />

<p>内存保护是操作系统的一个决定性的特性，确保程序的BUG不会影响到其他程序和操作系统自己。</p>

<p>操作系统通常依赖硬件去实现内存保护，当程序使用一个非法的内存地址或者对指定的虚拟地址没有访问权，处理器会中断程序指令并且产生一个fault级别异常，然后陷入内核态，去处理这个操作。如果这个错误可以修复，内核通过代码修复，然后让程序继续运行，否则，摧毁该程序。</p>

<p>一种常见的可以修复的错误就是栈增长，大多数系统初始化一个进程通常只会分配一个stack页，当程序使用这个分配好的栈的更下层的时候，内核将会自动分配更多的空间，当然会有一个分配的最大值。</p>

<p>大多数系统调用接口让用户程序传递一个指针给系统内核，这个指针指向一个用户内存空间的一个可读可写的缓冲区。系统内核通过解引用这个指针和用户程序进行交互，但是存在以下两个问题。
1. 内核态出现页错误比在用户态出现页错误可能更加严重，如果内核在操作自己的数据结构的时候发生了页错误，这是一个内核BUG，解决错误的handler此时应该<code>panic</code>。但是当内核解引用用户程序传递过来的指针的时候，内核需要确认这个指针的是属于该用户程序的。</p>

<ol>
<li>内核的权限通常高于用户程序，用户可能会传递一个内核可以读取，但是该程序不能读取的内存地址。内核需要非常仔细的检查这类指针，因为这样可能会造成隐私信息泄露和破坏内核完整性。</li>
</ol>

<h2 id="page-fault-handler">page_fault_handler()</h2>

<pre><code class="language-C">    // LAB 3: Your code here.(1)
    if ((tf-&gt;tf_cs &amp; 3) == 0)
        panic(&quot;kernel page fault&quot;);

</code></pre>

<p>在8086模式下，寄存器CS,DS,ES等被称作段偏移，但是在保护模式下，CS,DS,ES等寄存器被用作段选择子，在<code>GDT</code>中选定相应的段，根据全局描述符中的信息，程序只能在相应的内存段中运行，读取，写入，否则会发生中断或者异常。</p>

<h2 id="user-mem-check"><code>user_mem_check</code></h2>

<pre><code class="language-C">int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
    // LAB 3: Your code here.
    if ((uintptr_t)va &gt;= ULIM)  {
        user_mem_check_addr = (uintptr_t) va;
        return -E_FAULT;
    }


    uintptr_t beg = ROUNDDOWN((uint32_t)va, PGSIZE);
    uintptr_t end = ROUNDUP((uintptr_t)va+len, PGSIZE);
    uintptr_t i;
    pte_t *phaddr_entry;
    
    for (i = beg; i != end; i += PGSIZE) {
        phaddr_entry = pgdir_walk(env-&gt;env_pgdir, (void *)i, false);
        if ( phaddr_entry == NULL || !(*phaddr_entry &amp; PTE_P)  || (*phaddr_entry &amp; perm ) != perm) { 
            user_mem_check_addr = i &lt; (uintptr_t)va ? (uintptr_t)va : i;
            cprintf(&quot;%x\n&quot;, user_mem_check_addr);
            return -E_FAULT;
        }
    }
    return 0;
}

</code></pre>

<p><code>BUG</code> ： 这里在调用pgdir_walk的时候把env-&gt;env_pgdir写成了kern_pgdir，用户一般都不会有内核的地址空间的读写权限，导致<code>make run</code>相关程序的时候发生失败。</p>

<h2 id="sys-cputs">sys_cputs()</h2>

<pre><code class="language-C">    // Check that the user has permission to read memory [s, s+len).
    // Destroy the environment if not.
    // LAB 3: Your code here.
    user_mem_assert(curenv, s, len, PTE_U);
</code></pre>

<h2 id="debuginfo-eip">debuginfo_eip()</h2>

<pre><code>    // Make sure this memory is valid.
    // Return -1 if it is not.  Hint: Call user_mem_check.
    // LAB 3: Your code here.
    if (user_mem_check(curenv, usd, sizeof(struct UserStabData), PTE_U) &lt; 0)
        return -1;

    stabs = usd-&gt;stabs;
    stab_end = usd-&gt;stab_end;
    stabstr = usd-&gt;stabstr;
    stabstr_end = usd-&gt;stabstr_end;

    // Make sure the STABS and string table memory is valid.
    // LAB 3: Your code here.
    if (user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) &lt; 0)
        return -1;
    if (user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) &lt; 0)
        return -1;
</code></pre>

<blockquote>
<p>Q: run user/breakpoint, you should be able to run backtrace from the kernel monitor and see the backtrace traverse into lib/libmain.c before the kernel panics with a page fault. What causes this page fault? You don&rsquo;t need to fix it, but you should understand why it happens.</p>
</blockquote>

<p>// todo</p>

<h1 id="make-grade">make grade</h1>

<pre><code class="language-bash">
make[1]: Leaving directory '/home/moonlight/lab'
divzero: OK (1.3s) 
softint: OK (1.0s) 
badsegment: OK (1.1s) 
Part A score: 30/30

faultread: OK (0.9s) 
faultreadkernel: OK (1.9s) 
faultwrite: OK (1.1s) 
faultwritekernel: OK (1.7s) 
breakpoint: OK (1.4s) 
testbss: OK (1.7s) 
hello: OK (2.2s) 
buggyhello: OK (2.0s) 
buggyhello2: OK (2.1s) 
evilhello: OK (1.7s) 
Part B score: 50/50

Score: 80/80

</code></pre>

<p>This completes the lab.</p>

<h1 id="总结">总结</h1>

<p>这一个lab完成的用户程序空间的创建并且运行，实现系统中断，异常的处理方法。
1. 两个有意思的challenge做不出来：单步中断和解决重复编写相同代码
2. IDT, TSS, CR2, 段选择子等概念模糊。</p>

    
    <div>
      <button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
    </div>
    <script src="http://localhost:1313/js/back2top.js"></script>
  </main>
  <div id="disqus-container">
  
    <button id="disqus-button" onclick="showComments()">Show comments</button>
    <div id="disqus-comments">
      
      
      
        <p><em>Disqus comments are disabled.</em></p>
        <script type="application/javascript">
          function showComments() {
            // Remove button
var disqusButton = document.getElementById('disqus-button');
disqusButton.parentNode.removeChild(disqusButton); 
// Un-hide comments
var disqusComments = document.getElementById('disqus-comments');
disqusComments.style.display = 'block'; 
          }
        </script>
      
      <noscript>Enable JavaScript to view Disqus comments.</noscript>
    </div>
  
</div>


          <footer role="contentinfo">
  
  
    Made with <a href="https://gohugo.io/">Hugo</a>. Themed by <a href="https://github.com/zwbetz-gh/cupper-hugo-theme">Cupper</a>. Analytics in comming.
  
</footer>

        </div>
      </div>
    </div>
    <script src="http://localhost:1313/js/prism.js"></script>
<script src="http://localhost:1313/js/dom-scripts.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css" integrity="sha384-dbVIfZGuN1Yq7/1Ocstc1lUEm+AT+/rCkibIcC/OmWo5f0EA48Vf8CytHzGrSwbQ" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js" integrity="sha384-2BKqo+exmr9su6dir+qCw08N2ZKRucY4PrGQPPWU1A7FtlCGjmEGFqXCv5nyM5Ij" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

    
    
    
  <script data-no-instant>document.write('<script src="/livereload.js?port=1313&mindelay=10&v=2"></' + 'script>')</script></body>
</html>
